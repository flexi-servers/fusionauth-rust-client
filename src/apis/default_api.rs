/*
 * FusionAuth API
 *
 * This is a FusionAuth server. Find out more at [https://fusionauth.io](https://fusionauth.io). You need to [set up an API key](https://fusionauth.io/docs/v1/tech/apis/authentication#managing-api-keys) in the FusionAuth instance you are using to test out the API calls.
 *
 * The version of the OpenAPI document: 1.60.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`action_user_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionUserWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activate_reactor_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivateReactorWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`approve_device_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApproveDeviceWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cancel_action_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelActionWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_password_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangePasswordWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`check_change_password_using_id_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CheckChangePasswordUsingIdWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`comment_on_user_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CommentOnUserWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`complete_verify_identity_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompleteVerifyIdentityWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`complete_web_authn_assertion_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompleteWebAuthnAssertionWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`complete_web_authn_login_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompleteWebAuthnLoginWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`complete_web_authn_registration_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompleteWebAuthnRegistrationWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateApiKeyError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_api_key_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateApiKeyWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_application`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateApplicationError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_application_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateApplicationRoleError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_application_role_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateApplicationRoleWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_application_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateApplicationWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_audit_log_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAuditLogWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_connector`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateConnectorError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_connector_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateConnectorWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_consent`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateConsentError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_consent_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateConsentWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_email_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEmailTemplateError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_email_template_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEmailTemplateWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_entity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEntityError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_entity_type`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEntityTypeError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_entity_type_permission`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEntityTypePermissionError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_entity_type_permission_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEntityTypePermissionWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_entity_type_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEntityTypeWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_entity_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEntityWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_family`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFamilyError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_family_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFamilyWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_form`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFormError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_form_field`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFormFieldError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_form_field_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFormFieldWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_form_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFormWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGroupError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_group_members_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGroupMembersWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_group_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGroupWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_identity_provider`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIdentityProviderError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_identity_provider_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIdentityProviderWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_introspect`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIntrospectError {
    DefaultResponse(models::OAuthError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_ip_access_control_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIpAccessControlListError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_ip_access_control_list_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIpAccessControlListWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_lambda`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateLambdaError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_lambda_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateLambdaWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_logout`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateLogoutError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_message_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMessageTemplateError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_message_template_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMessageTemplateWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_messenger`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMessengerError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_messenger_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMessengerWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_o_auth_scope`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateOAuthScopeError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_o_auth_scope_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateOAuthScopeWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_tenant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTenantError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_tenant_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTenantWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_theme`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateThemeError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_theme_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateThemeWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTokenError {
    DefaultResponse(models::OAuthError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user_action`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserActionError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user_action_reason`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserActionReasonError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user_action_reason_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserActionReasonWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user_action_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserActionWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user_change_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserChangePasswordError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user_consent`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserConsentError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user_consent_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserConsentWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user_link_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserLinkWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user_verify_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserVerifyEmailError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWebhookError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_webhook_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWebhookWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_api_key_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteApiKeyWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_application_role_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteApplicationRoleWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_application_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteApplicationWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_connector_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteConnectorWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_consent_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteConsentWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_email_template_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteEmailTemplateWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_entity_grant_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteEntityGrantWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_entity_type_permission_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteEntityTypePermissionWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_entity_type_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteEntityTypeWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_entity_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteEntityWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_form_field_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFormFieldWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_form_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFormWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_group_members_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteGroupMembersWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_group_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteGroupWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_identity_provider_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteIdentityProviderWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_ip_access_control_list_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteIpAccessControlListWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_jwt_refresh`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteJwtRefreshError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_key_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteKeyWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_lambda_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteLambdaWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_message_template_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMessageTemplateWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_messenger_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMessengerWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_o_auth_scope_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteOAuthScopeWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_tenant_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTenantWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_theme_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteThemeWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user_action_reason_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserActionReasonWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user_action_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserActionWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user_bulk`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserBulkError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user_link_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserLinkWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user_registration_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserRegistrationWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user_two_factor_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserTwoFactorWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_web_authn_credential_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWebAuthnCredentialWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_webhook_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWebhookWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enable_two_factor_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnableTwoFactorWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`exchange_refresh_token_for_jwt_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExchangeRefreshTokenForJwtWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`forgot_password_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ForgotPasswordWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`generate_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateKeyError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`generate_key_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateKeyWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`generate_two_factor_recovery_codes_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateTwoFactorRecoveryCodesWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`generate_two_factor_secret_using_jwt_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateTwoFactorSecretUsingJwtWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`identity_provider_login_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IdentityProviderLoginWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`import_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ImportKeyError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`import_key_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ImportKeyWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`import_refresh_tokens_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ImportRefreshTokensWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`import_users_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ImportUsersWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`import_web_authn_credential_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ImportWebAuthnCredentialWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issue_jwt_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssueJwtWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`login_ping_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LoginPingWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`login_ping_with_request_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LoginPingWithRequestWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`login_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LoginWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lookup_identity_provider_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupIdentityProviderWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modify_action_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModifyActionWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`passwordless_login_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PasswordlessLoginWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_api_key_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchApiKeyWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_application_role_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchApplicationRoleWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_application_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchApplicationWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_connector_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchConnectorWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_consent_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchConsentWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_email_template_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchEmailTemplateWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_entity_type_permission_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchEntityTypePermissionWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_entity_type_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchEntityTypeWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_entity_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchEntityWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_form_field_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchFormFieldWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_form_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchFormWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_group_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchGroupWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_identity_provider_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchIdentityProviderWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_integrations_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchIntegrationsWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_ip_access_control_list_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchIpAccessControlListWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_lambda_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchLambdaWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_message_template_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchMessageTemplateWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_messenger_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchMessengerWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_o_auth_scope_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchOAuthScopeWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_registration_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchRegistrationWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_system_configuration_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchSystemConfigurationWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_tenant_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchTenantWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_theme_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchThemeWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_user_action_reason_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchUserActionReasonWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_user_action_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchUserActionWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_user_consent_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchUserConsentWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_user_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchUserWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_webhook_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchWebhookWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reconcile_jwt_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReconcileJwtWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`register`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RegisterError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`register_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RegisterWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reindex_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReindexWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_user_from_family_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveUserFromFamilyWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_action_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveActionWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_api_key_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveApiKeyWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_application`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveApplicationError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_application_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveApplicationWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_audit_log_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveAuditLogWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_connector_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveConnectorWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_consent_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveConsentWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_daily_active_report_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveDailyActiveReportWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_device_user_code`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveDeviceUserCodeError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_email_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveEmailTemplateError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_email_template_preview_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveEmailTemplatePreviewWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_email_template_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveEmailTemplateWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_entity_grant_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveEntityGrantWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_entity_type_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveEntityTypeWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_entity_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveEntityWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_event_log_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveEventLogWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_families_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveFamiliesWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_family_members_by_family_id_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveFamilyMembersByFamilyIdWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_form_field_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveFormFieldWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_form_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveFormWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_group_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveGroupWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_identity_provider_by_type_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveIdentityProviderByTypeWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_identity_provider_link`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveIdentityProviderLinkError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_identity_provider_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveIdentityProviderWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_ip_access_control_list_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveIpAccessControlListWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_json_web_key_set_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveJsonWebKeySetWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_jwt_public_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveJwtPublicKeyError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_key_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveKeyWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_keys_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveKeysWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_lambda_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveLambdaWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_lambdas_by_type_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveLambdasByTypeWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_message_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveMessageTemplateError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_message_template_preview_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveMessageTemplatePreviewWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_message_template_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveMessageTemplateWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_messenger_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveMessengerWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_monthly_active_report_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveMonthlyActiveReportWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_o_auth_scope_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveOAuthScopeWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_oauth_configuration_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveOauthConfigurationWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_open_id_configuration_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveOpenIdConfigurationWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_password_validation_rules_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrievePasswordValidationRulesWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_password_validation_rules_with_tenant_id_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrievePasswordValidationRulesWithTenantIdWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_pending_children_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrievePendingChildrenWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_pending_link_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrievePendingLinkWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_reactor_metrics_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveReactorMetricsWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_refresh_token_by_id_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveRefreshTokenByIdWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_refresh_tokens_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveRefreshTokensWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_registration_report_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveRegistrationReportWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_registration_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveRegistrationWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_report_login`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveReportLoginError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveStatusError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_system_health_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveSystemHealthWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_tenant_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveTenantWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_theme_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveThemeWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_total_report_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveTotalReportWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_two_factor_recovery_codes_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveTwoFactorRecoveryCodesWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_two_factor_status_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveTwoFactorStatusWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveUserError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_user_action`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveUserActionError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_user_action_reason`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveUserActionReasonError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_user_action_reason_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveUserActionReasonWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_user_action_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveUserActionWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_user_actioning`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveUserActioningError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_user_change_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveUserChangePasswordError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_user_comments_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveUserCommentsWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_user_consent_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveUserConsentWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_user_consents_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveUserConsentsWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_user_info_from_access_token_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveUserInfoFromAccessTokenWithIdError {
    DefaultResponse(models::OAuthError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_user_recent_login`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveUserRecentLoginError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_user_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveUserWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_version_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveVersionWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_web_authn_credential_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveWebAuthnCredentialWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_web_authn_credentials_for_user_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveWebAuthnCredentialsForUserWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveWebhookError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_webhook_attempt_log_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveWebhookAttemptLogWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_webhook_event_log_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveWebhookEventLogWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_webhook_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveWebhookWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`revoke_refresh_token_by_id_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevokeRefreshTokenByIdWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`revoke_user_consent_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevokeUserConsentWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_applications_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchApplicationsWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_audit_logs_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchAuditLogsWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_consents_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchConsentsWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_email_templates_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchEmailTemplatesWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_entities_by_ids_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchEntitiesByIdsWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_entities_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchEntitiesWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_entity_grants_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchEntityGrantsWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_entity_types_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchEntityTypesWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_event_logs_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchEventLogsWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_group_members_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchGroupMembersWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_groups_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchGroupsWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_identity_providers_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchIdentityProvidersWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_ip_access_control_lists_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchIpAccessControlListsWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_keys_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchKeysWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_lambdas_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchLambdasWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_login_records_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchLoginRecordsWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_tenants_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchTenantsWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_themes_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchThemesWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_user_comments_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchUserCommentsWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_users_by_ids_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchUsersByIdsWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_users_by_query_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchUsersByQueryWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_webhook_event_logs_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchWebhookEventLogsWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_webhooks_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchWebhooksWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_email_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendEmailWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_family_request_email_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendFamilyRequestEmailWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_passwordless_code_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendPasswordlessCodeWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_two_factor_code_for_enable_disable_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendTwoFactorCodeForEnableDisableWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_two_factor_code_for_login_using_method_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendTwoFactorCodeForLoginUsingMethodWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_verify_identity_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendVerifyIdentityWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_identity_provider_login_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartIdentityProviderLoginWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_passwordless_login_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartPasswordlessLoginWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_two_factor_login_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartTwoFactorLoginWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_verify_identity_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartVerifyIdentityWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_web_authn_login_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartWebAuthnLoginWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_web_authn_registration_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartWebAuthnRegistrationWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_login_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorLoginWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_api_key_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateApiKeyWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_application_role_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateApplicationRoleWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_application_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateApplicationWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_connector_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConnectorWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_consent_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConsentWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_email_template_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateEmailTemplateWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_entity_type_permission_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateEntityTypePermissionWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_entity_type_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateEntityTypeWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_entity_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateEntityWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_form_field_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFormFieldWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_form_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFormWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_group_members_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGroupMembersWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_group_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGroupWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_identity_provider_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateIdentityProviderWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_integrations_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateIntegrationsWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_ip_access_control_list_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateIpAccessControlListWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_key_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateKeyWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_lambda_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateLambdaWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_message_template_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMessageTemplateWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_messenger_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMessengerWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_o_auth_scope_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateOAuthScopeWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_registration_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRegistrationWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_system_configuration_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSystemConfigurationWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_tenant_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTenantWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_theme_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateThemeWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_action_reason_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserActionReasonWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_action_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserActionWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_consent_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserConsentWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_family_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserFamilyWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_verify_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserVerifyEmailError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_verify_registration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserVerifyRegistrationError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_webhook_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWebhookWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upsert_entity_grant_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpsertEntityGrantWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validate_device_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateDeviceWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validate_jwt_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateJwtWithIdError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vend_jwt_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VendJwtWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`verify_identity_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VerifyIdentityWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`verify_user_registration_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VerifyUserRegistrationWithIdError {
    DefaultResponse(models::Errors),
    UnknownValue(serde_json::Value),
}


/// Takes an action on a user. The user being actioned is called the \"actionee\" and the user taking the action is called the \"actioner\". Both user ids are required in the request object.
pub async fn action_user_with_id(configuration: &configuration::Configuration, action_request: Option<models::ActionRequest>) -> Result<models::ActionResponse, Error<ActionUserWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_action_request = action_request;

    let uri_str = format!("{}/api/user/action", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_action_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ActionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ActionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActionUserWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Activates the FusionAuth Reactor using a license Id and optionally a license text (for air-gapped deployments)
pub async fn activate_reactor_with_id(configuration: &configuration::Configuration, reactor_request: Option<models::ReactorRequest>) -> Result<(), Error<ActivateReactorWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_reactor_request = reactor_request;

    let uri_str = format!("{}/api/reactor", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_reactor_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivateReactorWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Approve a device grant.
pub async fn approve_device_with_id(configuration: &configuration::Configuration, ) -> Result<models::DeviceApprovalResponse, Error<ApproveDeviceWithIdError>> {

    let uri_str = format!("{}/oauth2/device/approve", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeviceApprovalResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeviceApprovalResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApproveDeviceWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancels the user action.
pub async fn cancel_action_with_id(configuration: &configuration::Configuration, action_id: &str, action_request: Option<models::ActionRequest>) -> Result<models::ActionResponse, Error<CancelActionWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_action_id = action_id;
    let p_body_action_request = action_request;

    let uri_str = format!("{}/api/user/action/{actionId}", configuration.base_path, actionId=crate::apis::urlencode(p_path_action_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_action_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ActionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ActionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelActionWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Changes a user's password using the change password Id. This usually occurs after an email has been sent to the user and they clicked on a link to reset their password.  As of version 1.32.2, prefer sending the changePasswordId in the request body. To do this, omit the first parameter, and set the value in the request body.
pub async fn change_password_with_id(configuration: &configuration::Configuration, change_password_id: &str, change_password_request: Option<models::ChangePasswordRequest>) -> Result<models::ChangePasswordResponse, Error<ChangePasswordWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_change_password_id = change_password_id;
    let p_body_change_password_request = change_password_request;

    let uri_str = format!("{}/api/user/change-password/{changePasswordId}", configuration.base_path, changePasswordId=crate::apis::urlencode(p_path_change_password_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_change_password_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChangePasswordResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChangePasswordResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangePasswordWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Check to see if the user must obtain a Trust Token Id in order to complete a change password request. When a user has enabled Two-Factor authentication, before you are allowed to use the Change Password API to change your password, you must obtain a Trust Token by completing a Two-Factor Step-Up authentication.  An HTTP status code of 400 with a general error code of [TrustTokenRequired] indicates that a Trust Token is required to make a POST request to this API.
pub async fn check_change_password_using_id_with_id(configuration: &configuration::Configuration, change_password_id: &str) -> Result<(), Error<CheckChangePasswordUsingIdWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_change_password_id = change_password_id;

    let uri_str = format!("{}/api/user/change-password/{changePasswordId}", configuration.base_path, changePasswordId=crate::apis::urlencode(p_path_change_password_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CheckChangePasswordUsingIdWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds a comment to the user's account.
pub async fn comment_on_user_with_id(configuration: &configuration::Configuration, x_fusion_auth_tenant_id: Option<&str>, user_comment_request: Option<models::UserCommentRequest>) -> Result<models::UserCommentResponse, Error<CommentOnUserWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_user_comment_request = user_comment_request;

    let uri_str = format!("{}/api/user/comment", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_user_comment_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserCommentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserCommentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CommentOnUserWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Completes verification of an identity using verification codes from the Verify Start API.
pub async fn complete_verify_identity_with_id(configuration: &configuration::Configuration, verify_complete_request: Option<models::VerifyCompleteRequest>) -> Result<models::VerifyCompleteResponse, Error<CompleteVerifyIdentityWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_verify_complete_request = verify_complete_request;

    let uri_str = format!("{}/api/identity/verify/complete", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_verify_complete_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VerifyCompleteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VerifyCompleteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompleteVerifyIdentityWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Complete a WebAuthn authentication ceremony by validating the signature against the previously generated challenge without logging the user in
pub async fn complete_web_authn_assertion_with_id(configuration: &configuration::Configuration, web_authn_login_request: Option<models::WebAuthnLoginRequest>) -> Result<models::WebAuthnAssertResponse, Error<CompleteWebAuthnAssertionWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_web_authn_login_request = web_authn_login_request;

    let uri_str = format!("{}/api/webauthn/assert", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_web_authn_login_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebAuthnAssertResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebAuthnAssertResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompleteWebAuthnAssertionWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Complete a WebAuthn authentication ceremony by validating the signature against the previously generated challenge and then login the user in
pub async fn complete_web_authn_login_with_id(configuration: &configuration::Configuration, web_authn_login_request: Option<models::WebAuthnLoginRequest>) -> Result<models::LoginResponse, Error<CompleteWebAuthnLoginWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_web_authn_login_request = web_authn_login_request;

    let uri_str = format!("{}/api/webauthn/login", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_web_authn_login_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LoginResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LoginResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompleteWebAuthnLoginWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Complete a WebAuthn registration ceremony by validating the client request and saving the new credential
pub async fn complete_web_authn_registration_with_id(configuration: &configuration::Configuration, web_authn_register_complete_request: Option<models::WebAuthnRegisterCompleteRequest>) -> Result<models::WebAuthnRegisterCompleteResponse, Error<CompleteWebAuthnRegistrationWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_web_authn_register_complete_request = web_authn_register_complete_request;

    let uri_str = format!("{}/api/webauthn/register/complete", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_web_authn_register_complete_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebAuthnRegisterCompleteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebAuthnRegisterCompleteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompleteWebAuthnRegistrationWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an API key. You can optionally specify a unique Id for the key, if not provided one will be generated. an API key can only be created with equal or lesser authority. An API key cannot create another API key unless it is granted  to that API key.  If an API key is locked to a tenant, it can only create API Keys for that same tenant.
pub async fn create_api_key(configuration: &configuration::Configuration, api_key_request: Option<models::ApiKeyRequest>) -> Result<models::ApiKeyResponse, Error<CreateApiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_api_key_request = api_key_request;

    let uri_str = format!("{}/api/api-key", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_api_key_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiKeyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiKeyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an API key. You can optionally specify a unique Id for the key, if not provided one will be generated. an API key can only be created with equal or lesser authority. An API key cannot create another API key unless it is granted  to that API key.  If an API key is locked to a tenant, it can only create API Keys for that same tenant.
pub async fn create_api_key_with_id(configuration: &configuration::Configuration, key_id: &str, api_key_request: Option<models::ApiKeyRequest>) -> Result<models::ApiKeyResponse, Error<CreateApiKeyWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_key_id = key_id;
    let p_body_api_key_request = api_key_request;

    let uri_str = format!("{}/api/api-key/{keyId}", configuration.base_path, keyId=crate::apis::urlencode(p_path_key_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_api_key_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiKeyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiKeyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateApiKeyWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an application. You can optionally specify an Id for the application, if not provided one will be generated.
pub async fn create_application(configuration: &configuration::Configuration, x_fusion_auth_tenant_id: Option<&str>, application_request: Option<models::ApplicationRequest>) -> Result<models::ApplicationResponse, Error<CreateApplicationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_application_request = application_request;

    let uri_str = format!("{}/api/application", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_application_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateApplicationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new role for an application. You must specify the Id of the application you are creating the role for. You can optionally specify an Id for the role inside the ApplicationRole object itself, if not provided one will be generated.
pub async fn create_application_role(configuration: &configuration::Configuration, application_id: &str, x_fusion_auth_tenant_id: Option<&str>, application_request: Option<models::ApplicationRequest>) -> Result<models::ApplicationResponse, Error<CreateApplicationRoleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_application_id = application_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_application_request = application_request;

    let uri_str = format!("{}/api/application/{applicationId}/role", configuration.base_path, applicationId=crate::apis::urlencode(p_path_application_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_application_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateApplicationRoleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new role for an application. You must specify the Id of the application you are creating the role for. You can optionally specify an Id for the role inside the ApplicationRole object itself, if not provided one will be generated.
pub async fn create_application_role_with_id(configuration: &configuration::Configuration, application_id: &str, role_id: &str, x_fusion_auth_tenant_id: Option<&str>, application_request: Option<models::ApplicationRequest>) -> Result<models::ApplicationResponse, Error<CreateApplicationRoleWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_application_id = application_id;
    let p_path_role_id = role_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_application_request = application_request;

    let uri_str = format!("{}/api/application/{applicationId}/role/{roleId}", configuration.base_path, applicationId=crate::apis::urlencode(p_path_application_id), roleId=crate::apis::urlencode(p_path_role_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_application_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateApplicationRoleWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an application. You can optionally specify an Id for the application, if not provided one will be generated.
pub async fn create_application_with_id(configuration: &configuration::Configuration, application_id: &str, x_fusion_auth_tenant_id: Option<&str>, application_request: Option<models::ApplicationRequest>) -> Result<models::ApplicationResponse, Error<CreateApplicationWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_application_id = application_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_application_request = application_request;

    let uri_str = format!("{}/api/application/{applicationId}", configuration.base_path, applicationId=crate::apis::urlencode(p_path_application_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_application_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateApplicationWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an audit log with the message and user name (usually an email). Audit logs should be written anytime you make changes to the FusionAuth database. When using the FusionAuth App web interface, any changes are automatically written to the audit log. However, if you are accessing the API, you must write the audit logs yourself.
pub async fn create_audit_log_with_id(configuration: &configuration::Configuration, audit_log_request: Option<models::AuditLogRequest>) -> Result<models::AuditLogResponse, Error<CreateAuditLogWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_audit_log_request = audit_log_request;

    let uri_str = format!("{}/api/system/audit-log", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_audit_log_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuditLogResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuditLogResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAuditLogWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a connector.  You can optionally specify an Id for the connector, if not provided one will be generated.
pub async fn create_connector(configuration: &configuration::Configuration, connector_request: Option<models::ConnectorRequest>) -> Result<models::ConnectorResponse, Error<CreateConnectorError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_connector_request = connector_request;

    let uri_str = format!("{}/api/connector", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_connector_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConnectorResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConnectorResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateConnectorError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a connector.  You can optionally specify an Id for the connector, if not provided one will be generated.
pub async fn create_connector_with_id(configuration: &configuration::Configuration, connector_id: &str, connector_request: Option<models::ConnectorRequest>) -> Result<models::ConnectorResponse, Error<CreateConnectorWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_connector_id = connector_id;
    let p_body_connector_request = connector_request;

    let uri_str = format!("{}/api/connector/{connectorId}", configuration.base_path, connectorId=crate::apis::urlencode(p_path_connector_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_connector_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConnectorResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConnectorResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateConnectorWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a user consent type. You can optionally specify an Id for the consent type, if not provided one will be generated.
pub async fn create_consent(configuration: &configuration::Configuration, x_fusion_auth_tenant_id: Option<&str>, consent_request: Option<models::ConsentRequest>) -> Result<models::ConsentResponse, Error<CreateConsentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_consent_request = consent_request;

    let uri_str = format!("{}/api/consent", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_consent_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConsentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConsentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateConsentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a user consent type. You can optionally specify an Id for the consent type, if not provided one will be generated.
pub async fn create_consent_with_id(configuration: &configuration::Configuration, consent_id: &str, x_fusion_auth_tenant_id: Option<&str>, consent_request: Option<models::ConsentRequest>) -> Result<models::ConsentResponse, Error<CreateConsentWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_consent_id = consent_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_consent_request = consent_request;

    let uri_str = format!("{}/api/consent/{consentId}", configuration.base_path, consentId=crate::apis::urlencode(p_path_consent_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_consent_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConsentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConsentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateConsentWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an email template. You can optionally specify an Id for the template, if not provided one will be generated.
pub async fn create_email_template(configuration: &configuration::Configuration, x_fusion_auth_tenant_id: Option<&str>, email_template_request: Option<models::EmailTemplateRequest>) -> Result<models::EmailTemplateResponse, Error<CreateEmailTemplateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_email_template_request = email_template_request;

    let uri_str = format!("{}/api/email/template", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_email_template_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmailTemplateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmailTemplateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateEmailTemplateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an email template. You can optionally specify an Id for the template, if not provided one will be generated.
pub async fn create_email_template_with_id(configuration: &configuration::Configuration, email_template_id: &str, x_fusion_auth_tenant_id: Option<&str>, email_template_request: Option<models::EmailTemplateRequest>) -> Result<models::EmailTemplateResponse, Error<CreateEmailTemplateWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_email_template_id = email_template_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_email_template_request = email_template_request;

    let uri_str = format!("{}/api/email/template/{emailTemplateId}", configuration.base_path, emailTemplateId=crate::apis::urlencode(p_path_email_template_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_email_template_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmailTemplateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmailTemplateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateEmailTemplateWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an Entity. You can optionally specify an Id for the Entity. If not provided one will be generated.
pub async fn create_entity(configuration: &configuration::Configuration, x_fusion_auth_tenant_id: Option<&str>, entity_request: Option<models::EntityRequest>) -> Result<models::EntityResponse, Error<CreateEntityError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_entity_request = entity_request;

    let uri_str = format!("{}/api/entity", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_entity_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntityResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntityResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateEntityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a Entity Type. You can optionally specify an Id for the Entity Type, if not provided one will be generated.
pub async fn create_entity_type(configuration: &configuration::Configuration, entity_type_request: Option<models::EntityTypeRequest>) -> Result<models::EntityTypeResponse, Error<CreateEntityTypeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_entity_type_request = entity_type_request;

    let uri_str = format!("{}/api/entity/type", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_entity_type_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntityTypeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntityTypeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateEntityTypeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new permission for an entity type. You must specify the Id of the entity type you are creating the permission for. You can optionally specify an Id for the permission inside the EntityTypePermission object itself, if not provided one will be generated.
pub async fn create_entity_type_permission(configuration: &configuration::Configuration, entity_type_id: &str, entity_type_request: Option<models::EntityTypeRequest>) -> Result<models::EntityTypeResponse, Error<CreateEntityTypePermissionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_entity_type_id = entity_type_id;
    let p_body_entity_type_request = entity_type_request;

    let uri_str = format!("{}/api/entity/type/{entityTypeId}/permission", configuration.base_path, entityTypeId=crate::apis::urlencode(p_path_entity_type_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_entity_type_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntityTypeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntityTypeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateEntityTypePermissionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new permission for an entity type. You must specify the Id of the entity type you are creating the permission for. You can optionally specify an Id for the permission inside the EntityTypePermission object itself, if not provided one will be generated.
pub async fn create_entity_type_permission_with_id(configuration: &configuration::Configuration, entity_type_id: &str, permission_id: &str, entity_type_request: Option<models::EntityTypeRequest>) -> Result<models::EntityTypeResponse, Error<CreateEntityTypePermissionWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_entity_type_id = entity_type_id;
    let p_path_permission_id = permission_id;
    let p_body_entity_type_request = entity_type_request;

    let uri_str = format!("{}/api/entity/type/{entityTypeId}/permission/{permissionId}", configuration.base_path, entityTypeId=crate::apis::urlencode(p_path_entity_type_id), permissionId=crate::apis::urlencode(p_path_permission_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_entity_type_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntityTypeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntityTypeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateEntityTypePermissionWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a Entity Type. You can optionally specify an Id for the Entity Type, if not provided one will be generated.
pub async fn create_entity_type_with_id(configuration: &configuration::Configuration, entity_type_id: &str, entity_type_request: Option<models::EntityTypeRequest>) -> Result<models::EntityTypeResponse, Error<CreateEntityTypeWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_entity_type_id = entity_type_id;
    let p_body_entity_type_request = entity_type_request;

    let uri_str = format!("{}/api/entity/type/{entityTypeId}", configuration.base_path, entityTypeId=crate::apis::urlencode(p_path_entity_type_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_entity_type_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntityTypeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntityTypeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateEntityTypeWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an Entity. You can optionally specify an Id for the Entity. If not provided one will be generated.
pub async fn create_entity_with_id(configuration: &configuration::Configuration, entity_id: &str, x_fusion_auth_tenant_id: Option<&str>, entity_request: Option<models::EntityRequest>) -> Result<models::EntityResponse, Error<CreateEntityWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_entity_id = entity_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_entity_request = entity_request;

    let uri_str = format!("{}/api/entity/{entityId}", configuration.base_path, entityId=crate::apis::urlencode(p_path_entity_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_entity_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntityResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntityResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateEntityWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a family with the user Id in the request as the owner and sole member of the family. You can optionally specify an Id for the family, if not provided one will be generated.
pub async fn create_family(configuration: &configuration::Configuration, x_fusion_auth_tenant_id: Option<&str>, family_request: Option<models::FamilyRequest>) -> Result<models::FamilyResponse, Error<CreateFamilyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_family_request = family_request;

    let uri_str = format!("{}/api/user/family", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_family_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FamilyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FamilyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateFamilyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a family with the user Id in the request as the owner and sole member of the family. You can optionally specify an Id for the family, if not provided one will be generated.
pub async fn create_family_with_id(configuration: &configuration::Configuration, family_id: &str, x_fusion_auth_tenant_id: Option<&str>, family_request: Option<models::FamilyRequest>) -> Result<models::FamilyResponse, Error<CreateFamilyWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_family_id = family_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_family_request = family_request;

    let uri_str = format!("{}/api/user/family/{familyId}", configuration.base_path, familyId=crate::apis::urlencode(p_path_family_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_family_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FamilyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FamilyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateFamilyWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a form.  You can optionally specify an Id for the form, if not provided one will be generated.
pub async fn create_form(configuration: &configuration::Configuration, form_request: Option<models::FormRequest>) -> Result<models::FormResponse, Error<CreateFormError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_form_request = form_request;

    let uri_str = format!("{}/api/form", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_form_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FormResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FormResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateFormError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a form field.  You can optionally specify an Id for the form, if not provided one will be generated.
pub async fn create_form_field(configuration: &configuration::Configuration, form_field_request: Option<models::FormFieldRequest>) -> Result<models::FormFieldResponse, Error<CreateFormFieldError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_form_field_request = form_field_request;

    let uri_str = format!("{}/api/form/field", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_form_field_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FormFieldResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FormFieldResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateFormFieldError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a form field.  You can optionally specify an Id for the form, if not provided one will be generated.
pub async fn create_form_field_with_id(configuration: &configuration::Configuration, field_id: &str, form_field_request: Option<models::FormFieldRequest>) -> Result<models::FormFieldResponse, Error<CreateFormFieldWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_field_id = field_id;
    let p_body_form_field_request = form_field_request;

    let uri_str = format!("{}/api/form/field/{fieldId}", configuration.base_path, fieldId=crate::apis::urlencode(p_path_field_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_form_field_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FormFieldResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FormFieldResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateFormFieldWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a form.  You can optionally specify an Id for the form, if not provided one will be generated.
pub async fn create_form_with_id(configuration: &configuration::Configuration, form_id: &str, form_request: Option<models::FormRequest>) -> Result<models::FormResponse, Error<CreateFormWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_form_id = form_id;
    let p_body_form_request = form_request;

    let uri_str = format!("{}/api/form/{formId}", configuration.base_path, formId=crate::apis::urlencode(p_path_form_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_form_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FormResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FormResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateFormWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a group. You can optionally specify an Id for the group, if not provided one will be generated.
pub async fn create_group(configuration: &configuration::Configuration, x_fusion_auth_tenant_id: Option<&str>, group_request: Option<models::GroupRequest>) -> Result<models::GroupResponse, Error<CreateGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_group_request = group_request;

    let uri_str = format!("{}/api/group", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_group_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a member in a group.
pub async fn create_group_members_with_id(configuration: &configuration::Configuration, member_request: Option<models::MemberRequest>) -> Result<models::MemberResponse, Error<CreateGroupMembersWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_member_request = member_request;

    let uri_str = format!("{}/api/group/member", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_member_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MemberResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MemberResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateGroupMembersWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a group. You can optionally specify an Id for the group, if not provided one will be generated.
pub async fn create_group_with_id(configuration: &configuration::Configuration, group_id: &str, x_fusion_auth_tenant_id: Option<&str>, group_request: Option<models::GroupRequest>) -> Result<models::GroupResponse, Error<CreateGroupWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_group_request = group_request;

    let uri_str = format!("{}/api/group/{groupId}", configuration.base_path, groupId=crate::apis::urlencode(p_path_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_group_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateGroupWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an identity provider. You can optionally specify an Id for the identity provider, if not provided one will be generated.
pub async fn create_identity_provider(configuration: &configuration::Configuration, identity_provider_request: Option<models::IdentityProviderRequest>) -> Result<models::IdentityProviderResponse, Error<CreateIdentityProviderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_identity_provider_request = identity_provider_request;

    let uri_str = format!("{}/api/identity-provider", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_identity_provider_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentityProviderResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentityProviderResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateIdentityProviderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an identity provider. You can optionally specify an Id for the identity provider, if not provided one will be generated.
pub async fn create_identity_provider_with_id(configuration: &configuration::Configuration, identity_provider_id: &str, identity_provider_request: Option<models::IdentityProviderRequest>) -> Result<models::IdentityProviderResponse, Error<CreateIdentityProviderWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_identity_provider_id = identity_provider_id;
    let p_body_identity_provider_request = identity_provider_request;

    let uri_str = format!("{}/api/identity-provider/{identityProviderId}", configuration.base_path, identityProviderId=crate::apis::urlencode(p_path_identity_provider_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_identity_provider_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentityProviderResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentityProviderResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateIdentityProviderWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Inspect an access token issued as the result of the Client Credentials Grant. OR Inspect an access token issued as the result of the User based grant such as the Authorization Code Grant, Implicit Grant, the User Credentials Grant or the Refresh Grant.
pub async fn create_introspect(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<CreateIntrospectError>> {

    let uri_str = format!("{}/oauth2/introspect", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateIntrospectError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an IP Access Control List. You can optionally specify an Id on this create request, if one is not provided one will be generated.
pub async fn create_ip_access_control_list(configuration: &configuration::Configuration, ip_access_control_list_request: Option<models::IpAccessControlListRequest>) -> Result<models::IpAccessControlListResponse, Error<CreateIpAccessControlListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_ip_access_control_list_request = ip_access_control_list_request;

    let uri_str = format!("{}/api/ip-acl", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_ip_access_control_list_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IpAccessControlListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IpAccessControlListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateIpAccessControlListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an IP Access Control List. You can optionally specify an Id on this create request, if one is not provided one will be generated.
pub async fn create_ip_access_control_list_with_id(configuration: &configuration::Configuration, access_control_list_id: &str, ip_access_control_list_request: Option<models::IpAccessControlListRequest>) -> Result<models::IpAccessControlListResponse, Error<CreateIpAccessControlListWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_access_control_list_id = access_control_list_id;
    let p_body_ip_access_control_list_request = ip_access_control_list_request;

    let uri_str = format!("{}/api/ip-acl/{accessControlListId}", configuration.base_path, accessControlListId=crate::apis::urlencode(p_path_access_control_list_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_ip_access_control_list_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IpAccessControlListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IpAccessControlListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateIpAccessControlListWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a Lambda. You can optionally specify an Id for the lambda, if not provided one will be generated.
pub async fn create_lambda(configuration: &configuration::Configuration, lambda_request: Option<models::LambdaRequest>) -> Result<models::LambdaResponse, Error<CreateLambdaError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_lambda_request = lambda_request;

    let uri_str = format!("{}/api/lambda", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_lambda_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LambdaResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LambdaResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateLambdaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a Lambda. You can optionally specify an Id for the lambda, if not provided one will be generated.
pub async fn create_lambda_with_id(configuration: &configuration::Configuration, lambda_id: &str, lambda_request: Option<models::LambdaRequest>) -> Result<models::LambdaResponse, Error<CreateLambdaWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_lambda_id = lambda_id;
    let p_body_lambda_request = lambda_request;

    let uri_str = format!("{}/api/lambda/{lambdaId}", configuration.base_path, lambdaId=crate::apis::urlencode(p_path_lambda_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_lambda_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LambdaResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LambdaResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateLambdaWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Logout API is intended to be used to remove the refresh token and access token cookies if they exist on the client and revoke the refresh token stored. This API takes the refresh token in the JSON body. OR The Logout API is intended to be used to remove the refresh token and access token cookies if they exist on the client and revoke the refresh token stored. This API does nothing if the request does not contain an access token or refresh token cookies.
pub async fn create_logout(configuration: &configuration::Configuration, global: Option<&str>, refresh_token: Option<&str>, logout_request: Option<models::LogoutRequest>) -> Result<(), Error<CreateLogoutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_global = global;
    let p_query_refresh_token = refresh_token;
    let p_body_logout_request = logout_request;

    let uri_str = format!("{}/api/logout", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_global {
        req_builder = req_builder.query(&[("global", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_refresh_token {
        req_builder = req_builder.query(&[("refreshToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_logout_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateLogoutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an message template. You can optionally specify an Id for the template, if not provided one will be generated.
pub async fn create_message_template(configuration: &configuration::Configuration, message_template_request: Option<models::MessageTemplateRequest>) -> Result<models::MessageTemplateResponse, Error<CreateMessageTemplateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_message_template_request = message_template_request;

    let uri_str = format!("{}/api/message/template", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_message_template_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MessageTemplateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MessageTemplateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateMessageTemplateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an message template. You can optionally specify an Id for the template, if not provided one will be generated.
pub async fn create_message_template_with_id(configuration: &configuration::Configuration, message_template_id: &str, message_template_request: Option<models::MessageTemplateRequest>) -> Result<models::MessageTemplateResponse, Error<CreateMessageTemplateWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_message_template_id = message_template_id;
    let p_body_message_template_request = message_template_request;

    let uri_str = format!("{}/api/message/template/{messageTemplateId}", configuration.base_path, messageTemplateId=crate::apis::urlencode(p_path_message_template_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_message_template_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MessageTemplateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MessageTemplateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateMessageTemplateWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a messenger.  You can optionally specify an Id for the messenger, if not provided one will be generated.
pub async fn create_messenger(configuration: &configuration::Configuration, messenger_request: Option<models::MessengerRequest>) -> Result<models::MessengerResponse, Error<CreateMessengerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_messenger_request = messenger_request;

    let uri_str = format!("{}/api/messenger", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_messenger_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MessengerResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MessengerResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateMessengerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a messenger.  You can optionally specify an Id for the messenger, if not provided one will be generated.
pub async fn create_messenger_with_id(configuration: &configuration::Configuration, messenger_id: &str, messenger_request: Option<models::MessengerRequest>) -> Result<models::MessengerResponse, Error<CreateMessengerWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_messenger_id = messenger_id;
    let p_body_messenger_request = messenger_request;

    let uri_str = format!("{}/api/messenger/{messengerId}", configuration.base_path, messengerId=crate::apis::urlencode(p_path_messenger_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_messenger_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MessengerResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MessengerResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateMessengerWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new custom OAuth scope for an application. You must specify the Id of the application you are creating the scope for. You can optionally specify an Id for the OAuth scope on the URL, if not provided one will be generated.
pub async fn create_o_auth_scope(configuration: &configuration::Configuration, application_id: &str, x_fusion_auth_tenant_id: Option<&str>, application_o_auth_scope_request: Option<models::ApplicationOAuthScopeRequest>) -> Result<models::ApplicationOAuthScopeResponse, Error<CreateOAuthScopeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_application_id = application_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_application_o_auth_scope_request = application_o_auth_scope_request;

    let uri_str = format!("{}/api/application/{applicationId}/scope", configuration.base_path, applicationId=crate::apis::urlencode(p_path_application_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_application_o_auth_scope_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationOAuthScopeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationOAuthScopeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateOAuthScopeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new custom OAuth scope for an application. You must specify the Id of the application you are creating the scope for. You can optionally specify an Id for the OAuth scope on the URL, if not provided one will be generated.
pub async fn create_o_auth_scope_with_id(configuration: &configuration::Configuration, application_id: &str, scope_id: &str, x_fusion_auth_tenant_id: Option<&str>, application_o_auth_scope_request: Option<models::ApplicationOAuthScopeRequest>) -> Result<models::ApplicationOAuthScopeResponse, Error<CreateOAuthScopeWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_application_id = application_id;
    let p_path_scope_id = scope_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_application_o_auth_scope_request = application_o_auth_scope_request;

    let uri_str = format!("{}/api/application/{applicationId}/scope/{scopeId}", configuration.base_path, applicationId=crate::apis::urlencode(p_path_application_id), scopeId=crate::apis::urlencode(p_path_scope_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_application_o_auth_scope_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationOAuthScopeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationOAuthScopeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateOAuthScopeWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a tenant. You can optionally specify an Id for the tenant, if not provided one will be generated.
pub async fn create_tenant(configuration: &configuration::Configuration, x_fusion_auth_tenant_id: Option<&str>, tenant_request: Option<models::TenantRequest>) -> Result<models::TenantResponse, Error<CreateTenantError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_tenant_request = tenant_request;

    let uri_str = format!("{}/api/tenant", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_tenant_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TenantResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TenantResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateTenantError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a tenant. You can optionally specify an Id for the tenant, if not provided one will be generated.
pub async fn create_tenant_with_id(configuration: &configuration::Configuration, tenant_id: &str, x_fusion_auth_tenant_id: Option<&str>, tenant_request: Option<models::TenantRequest>) -> Result<models::TenantResponse, Error<CreateTenantWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_tenant_id = tenant_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_tenant_request = tenant_request;

    let uri_str = format!("{}/api/tenant/{tenantId}", configuration.base_path, tenantId=crate::apis::urlencode(p_path_tenant_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_tenant_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TenantResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TenantResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateTenantWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a Theme. You can optionally specify an Id for the theme, if not provided one will be generated.
pub async fn create_theme(configuration: &configuration::Configuration, theme_request: Option<models::ThemeRequest>) -> Result<models::ThemeResponse, Error<CreateThemeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_theme_request = theme_request;

    let uri_str = format!("{}/api/theme", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_theme_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ThemeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ThemeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateThemeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a Theme. You can optionally specify an Id for the theme, if not provided one will be generated.
pub async fn create_theme_with_id(configuration: &configuration::Configuration, theme_id: &str, theme_request: Option<models::ThemeRequest>) -> Result<models::ThemeResponse, Error<CreateThemeWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_theme_id = theme_id;
    let p_body_theme_request = theme_request;

    let uri_str = format!("{}/api/theme/{themeId}", configuration.base_path, themeId=crate::apis::urlencode(p_path_theme_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_theme_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ThemeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ThemeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateThemeWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange User Credentials for a Token. If you will be using the Resource Owner Password Credential Grant, you will make a request to the Token endpoint to exchange the user’s email and password for an access token. OR Exchange a Refresh Token for an Access Token. If you will be using the Refresh Token Grant, you will make a request to the Token endpoint to exchange the user’s refresh token for an access token. OR Exchanges an OAuth authorization code and code_verifier for an access token. Makes a request to the Token endpoint to exchange the authorization code returned from the Authorize endpoint and a code_verifier for an access token. OR Exchanges an OAuth authorization code for an access token. Makes a request to the Token endpoint to exchange the authorization code returned from the Authorize endpoint for an access token. OR Make a Client Credentials grant request to obtain an access token.
pub async fn create_token(configuration: &configuration::Configuration, ) -> Result<models::AccessToken, Error<CreateTokenError>> {

    let uri_str = format!("{}/oauth2/token", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccessToken`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccessToken`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a user. You can optionally specify an Id for the user, if not provided one will be generated.
pub async fn create_user(configuration: &configuration::Configuration, x_fusion_auth_tenant_id: Option<&str>, user_request: Option<models::UserRequest>) -> Result<models::UserResponse, Error<CreateUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_user_request = user_request;

    let uri_str = format!("{}/api/user", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a user action. This action cannot be taken on a user until this call successfully returns. Anytime after that the user action can be applied to any user.
pub async fn create_user_action(configuration: &configuration::Configuration, x_fusion_auth_tenant_id: Option<&str>, user_action_request: Option<models::UserActionRequest>) -> Result<models::UserActionResponse, Error<CreateUserActionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_user_action_request = user_action_request;

    let uri_str = format!("{}/api/user-action", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_user_action_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserActionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserActionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateUserActionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a user reason. This user action reason cannot be used when actioning a user until this call completes successfully. Anytime after that the user action reason can be used.
pub async fn create_user_action_reason(configuration: &configuration::Configuration, user_action_reason_request: Option<models::UserActionReasonRequest>) -> Result<models::UserActionReasonResponse, Error<CreateUserActionReasonError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_user_action_reason_request = user_action_reason_request;

    let uri_str = format!("{}/api/user-action-reason", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_user_action_reason_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserActionReasonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserActionReasonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateUserActionReasonError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a user reason. This user action reason cannot be used when actioning a user until this call completes successfully. Anytime after that the user action reason can be used.
pub async fn create_user_action_reason_with_id(configuration: &configuration::Configuration, user_action_reason_id: &str, user_action_reason_request: Option<models::UserActionReasonRequest>) -> Result<models::UserActionReasonResponse, Error<CreateUserActionReasonWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_action_reason_id = user_action_reason_id;
    let p_body_user_action_reason_request = user_action_reason_request;

    let uri_str = format!("{}/api/user-action-reason/{userActionReasonId}", configuration.base_path, userActionReasonId=crate::apis::urlencode(p_path_user_action_reason_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_user_action_reason_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserActionReasonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserActionReasonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateUserActionReasonWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a user action. This action cannot be taken on a user until this call successfully returns. Anytime after that the user action can be applied to any user.
pub async fn create_user_action_with_id(configuration: &configuration::Configuration, user_action_id: &str, x_fusion_auth_tenant_id: Option<&str>, user_action_request: Option<models::UserActionRequest>) -> Result<models::UserActionResponse, Error<CreateUserActionWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_action_id = user_action_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_user_action_request = user_action_request;

    let uri_str = format!("{}/api/user-action/{userActionId}", configuration.base_path, userActionId=crate::apis::urlencode(p_path_user_action_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_user_action_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserActionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserActionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateUserActionWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Changes a user's password using their access token (JWT) instead of the changePasswordId A common use case for this method will be if you want to allow the user to change their own password.  Remember to send refreshToken in the request body if you want to get a new refresh token when login using the returned oneTimePassword. OR Changes a user's password using their identity (loginId and password). Using a loginId instead of the changePasswordId bypasses the email verification and allows a password to be changed directly without first calling the #forgotPassword method.
pub async fn create_user_change_password(configuration: &configuration::Configuration, change_password_request: Option<models::ChangePasswordRequest>) -> Result<models::ChangePasswordResponse, Error<CreateUserChangePasswordError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_change_password_request = change_password_request;

    let uri_str = format!("{}/api/user/change-password", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_change_password_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChangePasswordResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChangePasswordResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateUserChangePasswordError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a single User consent.
pub async fn create_user_consent(configuration: &configuration::Configuration, user_consent_request: Option<models::UserConsentRequest>) -> Result<models::UserConsentResponse, Error<CreateUserConsentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_user_consent_request = user_consent_request;

    let uri_str = format!("{}/api/user/consent", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_user_consent_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserConsentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserConsentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateUserConsentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a single User consent.
pub async fn create_user_consent_with_id(configuration: &configuration::Configuration, user_consent_id: &str, user_consent_request: Option<models::UserConsentRequest>) -> Result<models::UserConsentResponse, Error<CreateUserConsentWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_consent_id = user_consent_id;
    let p_body_user_consent_request = user_consent_request;

    let uri_str = format!("{}/api/user/consent/{userConsentId}", configuration.base_path, userConsentId=crate::apis::urlencode(p_path_user_consent_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_user_consent_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserConsentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserConsentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateUserConsentWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Link an external user from a 3rd party identity provider to a FusionAuth user.
pub async fn create_user_link_with_id(configuration: &configuration::Configuration, identity_provider_link_request: Option<models::IdentityProviderLinkRequest>) -> Result<models::IdentityProviderLinkResponse, Error<CreateUserLinkWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_identity_provider_link_request = identity_provider_link_request;

    let uri_str = format!("{}/api/identity-provider/link", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_identity_provider_link_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentityProviderLinkResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentityProviderLinkResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateUserLinkWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Administratively verify a user's email address. Use this method to bypass email verification for the user.  The request body will contain the userId to be verified. An API key is required when sending the userId in the request body. OR Confirms a user's email address.   The request body will contain the verificationId. You may also be required to send a one-time use code based upon your configuration. When  the tenant is configured to gate a user until their email address is verified, this procedures requires two values instead of one.  The verificationId is a high entropy value and the one-time use code is a low entropy value that is easily entered in a user interactive form. The  two values together are able to confirm a user's email address and mark the user's email address as verified.
pub async fn create_user_verify_email(configuration: &configuration::Configuration, verify_email_request: Option<models::VerifyEmailRequest>) -> Result<(), Error<CreateUserVerifyEmailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_verify_email_request = verify_email_request;

    let uri_str = format!("{}/api/user/verify-email", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_verify_email_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateUserVerifyEmailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a user. You can optionally specify an Id for the user, if not provided one will be generated.
pub async fn create_user_with_id(configuration: &configuration::Configuration, user_id: &str, x_fusion_auth_tenant_id: Option<&str>, user_request: Option<models::UserRequest>) -> Result<models::UserResponse, Error<CreateUserWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_user_request = user_request;

    let uri_str = format!("{}/api/user/{userId}", configuration.base_path, userId=crate::apis::urlencode(p_path_user_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateUserWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a webhook. You can optionally specify an Id for the webhook, if not provided one will be generated.
pub async fn create_webhook(configuration: &configuration::Configuration, webhook_request: Option<models::WebhookRequest>) -> Result<models::WebhookResponse, Error<CreateWebhookError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_webhook_request = webhook_request;

    let uri_str = format!("{}/api/webhook", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_webhook_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebhookResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebhookResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateWebhookError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a webhook. You can optionally specify an Id for the webhook, if not provided one will be generated.
pub async fn create_webhook_with_id(configuration: &configuration::Configuration, webhook_id: &str, webhook_request: Option<models::WebhookRequest>) -> Result<models::WebhookResponse, Error<CreateWebhookWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_webhook_id = webhook_id;
    let p_body_webhook_request = webhook_request;

    let uri_str = format!("{}/api/webhook/{webhookId}", configuration.base_path, webhookId=crate::apis::urlencode(p_path_webhook_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_webhook_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebhookResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebhookResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateWebhookWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the API key for the given Id.
pub async fn delete_api_key_with_id(configuration: &configuration::Configuration, key_id: &str) -> Result<(), Error<DeleteApiKeyWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_key_id = key_id;

    let uri_str = format!("{}/api/api-key/{keyId}", configuration.base_path, keyId=crate::apis::urlencode(p_path_key_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteApiKeyWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Hard deletes an application role. This is a dangerous operation and should not be used in most circumstances. This permanently removes the given role from all users that had it.
pub async fn delete_application_role_with_id(configuration: &configuration::Configuration, application_id: &str, role_id: &str, x_fusion_auth_tenant_id: Option<&str>) -> Result<(), Error<DeleteApplicationRoleWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_application_id = application_id;
    let p_path_role_id = role_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/application/{applicationId}/role/{roleId}", configuration.base_path, applicationId=crate::apis::urlencode(p_path_application_id), roleId=crate::apis::urlencode(p_path_role_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteApplicationRoleWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Hard deletes an application. This is a dangerous operation and should not be used in most circumstances. This will delete the application, any registrations for that application, metrics and reports for the application, all the roles for the application, and any other data associated with the application. This operation could take a very long time, depending on the amount of data in your database. OR Deactivates the application with the given Id.
pub async fn delete_application_with_id(configuration: &configuration::Configuration, application_id: &str, hard_delete: Option<&str>, x_fusion_auth_tenant_id: Option<&str>) -> Result<(), Error<DeleteApplicationWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_application_id = application_id;
    let p_query_hard_delete = hard_delete;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/application/{applicationId}", configuration.base_path, applicationId=crate::apis::urlencode(p_path_application_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_hard_delete {
        req_builder = req_builder.query(&[("hardDelete", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteApplicationWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the connector for the given Id.
pub async fn delete_connector_with_id(configuration: &configuration::Configuration, connector_id: &str) -> Result<(), Error<DeleteConnectorWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_connector_id = connector_id;

    let uri_str = format!("{}/api/connector/{connectorId}", configuration.base_path, connectorId=crate::apis::urlencode(p_path_connector_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteConnectorWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the consent for the given Id.
pub async fn delete_consent_with_id(configuration: &configuration::Configuration, consent_id: &str, x_fusion_auth_tenant_id: Option<&str>) -> Result<(), Error<DeleteConsentWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_consent_id = consent_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/consent/{consentId}", configuration.base_path, consentId=crate::apis::urlencode(p_path_consent_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteConsentWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the email template for the given Id.
pub async fn delete_email_template_with_id(configuration: &configuration::Configuration, email_template_id: &str, x_fusion_auth_tenant_id: Option<&str>) -> Result<(), Error<DeleteEmailTemplateWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_email_template_id = email_template_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/email/template/{emailTemplateId}", configuration.base_path, emailTemplateId=crate::apis::urlencode(p_path_email_template_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteEmailTemplateWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes an Entity Grant for the given User or Entity.
pub async fn delete_entity_grant_with_id(configuration: &configuration::Configuration, entity_id: &str, recipient_entity_id: Option<&str>, user_id: Option<&str>, x_fusion_auth_tenant_id: Option<&str>) -> Result<(), Error<DeleteEntityGrantWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_entity_id = entity_id;
    let p_query_recipient_entity_id = recipient_entity_id;
    let p_query_user_id = user_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/entity/{entityId}/grant", configuration.base_path, entityId=crate::apis::urlencode(p_path_entity_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_recipient_entity_id {
        req_builder = req_builder.query(&[("recipientEntityId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("userId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteEntityGrantWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Hard deletes a permission. This is a dangerous operation and should not be used in most circumstances. This permanently removes the given permission from all grants that had it.
pub async fn delete_entity_type_permission_with_id(configuration: &configuration::Configuration, entity_type_id: &str, permission_id: &str) -> Result<(), Error<DeleteEntityTypePermissionWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_entity_type_id = entity_type_id;
    let p_path_permission_id = permission_id;

    let uri_str = format!("{}/api/entity/type/{entityTypeId}/permission/{permissionId}", configuration.base_path, entityTypeId=crate::apis::urlencode(p_path_entity_type_id), permissionId=crate::apis::urlencode(p_path_permission_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteEntityTypePermissionWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the Entity Type for the given Id.
pub async fn delete_entity_type_with_id(configuration: &configuration::Configuration, entity_type_id: &str) -> Result<(), Error<DeleteEntityTypeWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_entity_type_id = entity_type_id;

    let uri_str = format!("{}/api/entity/type/{entityTypeId}", configuration.base_path, entityTypeId=crate::apis::urlencode(p_path_entity_type_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteEntityTypeWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the Entity for the given Id.
pub async fn delete_entity_with_id(configuration: &configuration::Configuration, entity_id: &str, x_fusion_auth_tenant_id: Option<&str>) -> Result<(), Error<DeleteEntityWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_entity_id = entity_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/entity/{entityId}", configuration.base_path, entityId=crate::apis::urlencode(p_path_entity_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteEntityWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the form field for the given Id.
pub async fn delete_form_field_with_id(configuration: &configuration::Configuration, field_id: &str) -> Result<(), Error<DeleteFormFieldWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_field_id = field_id;

    let uri_str = format!("{}/api/form/field/{fieldId}", configuration.base_path, fieldId=crate::apis::urlencode(p_path_field_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteFormFieldWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the form for the given Id.
pub async fn delete_form_with_id(configuration: &configuration::Configuration, form_id: &str) -> Result<(), Error<DeleteFormWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_form_id = form_id;

    let uri_str = format!("{}/api/form/{formId}", configuration.base_path, formId=crate::apis::urlencode(p_path_form_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteFormWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes users as members of a group.
pub async fn delete_group_members_with_id(configuration: &configuration::Configuration, member_delete_request: Option<models::MemberDeleteRequest>) -> Result<(), Error<DeleteGroupMembersWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_member_delete_request = member_delete_request;

    let uri_str = format!("{}/api/group/member", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_member_delete_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteGroupMembersWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the group for the given Id.
pub async fn delete_group_with_id(configuration: &configuration::Configuration, group_id: &str, x_fusion_auth_tenant_id: Option<&str>) -> Result<(), Error<DeleteGroupWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/group/{groupId}", configuration.base_path, groupId=crate::apis::urlencode(p_path_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteGroupWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the identity provider for the given Id.
pub async fn delete_identity_provider_with_id(configuration: &configuration::Configuration, identity_provider_id: &str) -> Result<(), Error<DeleteIdentityProviderWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_identity_provider_id = identity_provider_id;

    let uri_str = format!("{}/api/identity-provider/{identityProviderId}", configuration.base_path, identityProviderId=crate::apis::urlencode(p_path_identity_provider_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteIdentityProviderWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the IP Access Control List for the given Id.
pub async fn delete_ip_access_control_list_with_id(configuration: &configuration::Configuration, ip_access_control_list_id: &str) -> Result<(), Error<DeleteIpAccessControlListWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ip_access_control_list_id = ip_access_control_list_id;

    let uri_str = format!("{}/api/ip-acl/{ipAccessControlListId}", configuration.base_path, ipAccessControlListId=crate::apis::urlencode(p_path_ip_access_control_list_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteIpAccessControlListWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Revokes refresh tokens using the information in the JSON body. The handling for this method is the same as the revokeRefreshToken method and is based on the information you provide in the RefreshDeleteRequest object. See that method for additional information. OR Revoke all refresh tokens that belong to a user by user Id for a specific application by applicationId. OR Revoke all refresh tokens that belong to a user by user Id. OR Revoke all refresh tokens that belong to an application by applicationId. OR Revokes a single refresh token by using the actual refresh token value. This refresh token value is sensitive, so  be careful with this API request. OR Revokes refresh tokens.  Usage examples:   - Delete a single refresh token, pass in only the token.       revokeRefreshToken(token)    - Delete all refresh tokens for a user, pass in only the userId.       revokeRefreshToken(null, userId)    - Delete all refresh tokens for a user for a specific application, pass in both the userId and the applicationId.       revokeRefreshToken(null, userId, applicationId)    - Delete all refresh tokens for an application       revokeRefreshToken(null, null, applicationId)  Note: <code>null</code> may be handled differently depending upon the programming language.  See also: (method names may vary by language... but you'll figure it out)   - revokeRefreshTokenById  - revokeRefreshTokenByToken  - revokeRefreshTokensByUserId  - revokeRefreshTokensByApplicationId  - revokeRefreshTokensByUserIdForApplication
pub async fn delete_jwt_refresh(configuration: &configuration::Configuration, user_id: Option<&str>, application_id: Option<&str>, token: Option<&str>, refresh_token_revoke_request: Option<models::RefreshTokenRevokeRequest>) -> Result<(), Error<DeleteJwtRefreshError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_user_id = user_id;
    let p_query_application_id = application_id;
    let p_query_token = token;
    let p_body_refresh_token_revoke_request = refresh_token_revoke_request;

    let uri_str = format!("{}/api/jwt/refresh", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("userId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_application_id {
        req_builder = req_builder.query(&[("applicationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_token {
        req_builder = req_builder.query(&[("token", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_refresh_token_revoke_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteJwtRefreshError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the key for the given Id.
pub async fn delete_key_with_id(configuration: &configuration::Configuration, key_id: &str) -> Result<(), Error<DeleteKeyWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_key_id = key_id;

    let uri_str = format!("{}/api/key/{keyId}", configuration.base_path, keyId=crate::apis::urlencode(p_path_key_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteKeyWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the lambda for the given Id.
pub async fn delete_lambda_with_id(configuration: &configuration::Configuration, lambda_id: &str) -> Result<(), Error<DeleteLambdaWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_lambda_id = lambda_id;

    let uri_str = format!("{}/api/lambda/{lambdaId}", configuration.base_path, lambdaId=crate::apis::urlencode(p_path_lambda_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteLambdaWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the message template for the given Id.
pub async fn delete_message_template_with_id(configuration: &configuration::Configuration, message_template_id: &str) -> Result<(), Error<DeleteMessageTemplateWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_message_template_id = message_template_id;

    let uri_str = format!("{}/api/message/template/{messageTemplateId}", configuration.base_path, messageTemplateId=crate::apis::urlencode(p_path_message_template_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteMessageTemplateWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the messenger for the given Id.
pub async fn delete_messenger_with_id(configuration: &configuration::Configuration, messenger_id: &str) -> Result<(), Error<DeleteMessengerWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_messenger_id = messenger_id;

    let uri_str = format!("{}/api/messenger/{messengerId}", configuration.base_path, messengerId=crate::apis::urlencode(p_path_messenger_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteMessengerWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Hard deletes a custom OAuth scope. OAuth workflows that are still requesting the deleted OAuth scope may fail depending on the application's unknown scope policy.
pub async fn delete_o_auth_scope_with_id(configuration: &configuration::Configuration, application_id: &str, scope_id: &str, x_fusion_auth_tenant_id: Option<&str>) -> Result<(), Error<DeleteOAuthScopeWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_application_id = application_id;
    let p_path_scope_id = scope_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/application/{applicationId}/scope/{scopeId}", configuration.base_path, applicationId=crate::apis::urlencode(p_path_application_id), scopeId=crate::apis::urlencode(p_path_scope_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteOAuthScopeWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the tenant based on the given request (sent to the API as JSON). This permanently deletes all information, metrics, reports and data associated with the tenant and everything under the tenant (applications, users, etc). OR Deletes the tenant for the given Id asynchronously. This method is helpful if you do not want to wait for the delete operation to complete. OR Deletes the tenant based on the given Id on the URL. This permanently deletes all information, metrics, reports and data associated with the tenant and everything under the tenant (applications, users, etc).
pub async fn delete_tenant_with_id(configuration: &configuration::Configuration, tenant_id: &str, x_fusion_auth_tenant_id: Option<&str>, r#async: Option<&str>, tenant_delete_request: Option<models::TenantDeleteRequest>) -> Result<(), Error<DeleteTenantWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_tenant_id = tenant_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_query_async = r#async;
    let p_body_tenant_delete_request = tenant_delete_request;

    let uri_str = format!("{}/api/tenant/{tenantId}", configuration.base_path, tenantId=crate::apis::urlencode(p_path_tenant_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_async {
        req_builder = req_builder.query(&[("async", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_tenant_delete_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteTenantWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the theme for the given Id.
pub async fn delete_theme_with_id(configuration: &configuration::Configuration, theme_id: &str) -> Result<(), Error<DeleteThemeWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_theme_id = theme_id;

    let uri_str = format!("{}/api/theme/{themeId}", configuration.base_path, themeId=crate::apis::urlencode(p_path_theme_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteThemeWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the user action reason for the given Id.
pub async fn delete_user_action_reason_with_id(configuration: &configuration::Configuration, user_action_reason_id: &str) -> Result<(), Error<DeleteUserActionReasonWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_action_reason_id = user_action_reason_id;

    let uri_str = format!("{}/api/user-action-reason/{userActionReasonId}", configuration.base_path, userActionReasonId=crate::apis::urlencode(p_path_user_action_reason_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteUserActionReasonWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the user action for the given Id. This permanently deletes the user action and also any history and logs of the action being applied to any users. OR Deactivates the user action with the given Id.
pub async fn delete_user_action_with_id(configuration: &configuration::Configuration, user_action_id: &str, hard_delete: Option<&str>, x_fusion_auth_tenant_id: Option<&str>) -> Result<(), Error<DeleteUserActionWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_action_id = user_action_id;
    let p_query_hard_delete = hard_delete;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/user-action/{userActionId}", configuration.base_path, userActionId=crate::apis::urlencode(p_path_user_action_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_hard_delete {
        req_builder = req_builder.query(&[("hardDelete", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteUserActionWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the users with the given Ids, or users matching the provided JSON query or queryString. The order of preference is Ids, query and then queryString, it is recommended to only provide one of the three for the request.  This method can be used to deactivate or permanently delete (hard-delete) users based upon the hardDelete boolean in the request body. Using the dryRun parameter you may also request the result of the action without actually deleting or deactivating any users. OR Deactivates the users with the given Ids.
pub async fn delete_user_bulk(configuration: &configuration::Configuration, user_ids: Option<&str>, dry_run: Option<&str>, hard_delete: Option<&str>, user_delete_request: Option<models::UserDeleteRequest>) -> Result<models::UserDeleteResponse, Error<DeleteUserBulkError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_user_ids = user_ids;
    let p_query_dry_run = dry_run;
    let p_query_hard_delete = hard_delete;
    let p_body_user_delete_request = user_delete_request;

    let uri_str = format!("{}/api/user/bulk", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_user_ids {
        req_builder = req_builder.query(&[("userIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dry_run {
        req_builder = req_builder.query(&[("dryRun", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_hard_delete {
        req_builder = req_builder.query(&[("hardDelete", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_user_delete_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserDeleteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserDeleteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteUserBulkError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove an existing link that has been made from a 3rd party identity provider to a FusionAuth user.
pub async fn delete_user_link_with_id(configuration: &configuration::Configuration, identity_provider_id: Option<&str>, identity_provider_user_id: Option<&str>, user_id: Option<&str>) -> Result<models::IdentityProviderLinkResponse, Error<DeleteUserLinkWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_identity_provider_id = identity_provider_id;
    let p_query_identity_provider_user_id = identity_provider_user_id;
    let p_query_user_id = user_id;

    let uri_str = format!("{}/api/identity-provider/link", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_identity_provider_id {
        req_builder = req_builder.query(&[("identityProviderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_identity_provider_user_id {
        req_builder = req_builder.query(&[("identityProviderUserId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("userId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentityProviderLinkResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentityProviderLinkResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteUserLinkWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the user registration for the given user and application along with the given JSON body that contains the event information. OR Deletes the user registration for the given user and application.
pub async fn delete_user_registration_with_id(configuration: &configuration::Configuration, user_id: &str, application_id: &str, x_fusion_auth_tenant_id: Option<&str>, registration_delete_request: Option<models::RegistrationDeleteRequest>) -> Result<(), Error<DeleteUserRegistrationWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_path_application_id = application_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_registration_delete_request = registration_delete_request;

    let uri_str = format!("{}/api/user/registration/{userId}/{applicationId}", configuration.base_path, userId=crate::apis::urlencode(p_path_user_id), applicationId=crate::apis::urlencode(p_path_application_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_registration_delete_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteUserRegistrationWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Disable two-factor authentication for a user using a JSON body rather than URL parameters. OR Disable two-factor authentication for a user.
pub async fn delete_user_two_factor_with_id(configuration: &configuration::Configuration, user_id: &str, method_id: Option<&str>, code: Option<&str>, two_factor_disable_request: Option<models::TwoFactorDisableRequest>) -> Result<(), Error<DeleteUserTwoFactorWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_query_method_id = method_id;
    let p_query_code = code;
    let p_body_two_factor_disable_request = two_factor_disable_request;

    let uri_str = format!("{}/api/user/two-factor/{userId}", configuration.base_path, userId=crate::apis::urlencode(p_path_user_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_method_id {
        req_builder = req_builder.query(&[("methodId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_code {
        req_builder = req_builder.query(&[("code", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_two_factor_disable_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteUserTwoFactorWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the user based on the given request (sent to the API as JSON). This permanently deletes all information, metrics, reports and data associated with the user. OR Deletes the user for the given Id. This permanently deletes all information, metrics, reports and data associated with the user. OR Deactivates the user with the given Id.
pub async fn delete_user_with_id(configuration: &configuration::Configuration, user_id: &str, x_fusion_auth_tenant_id: Option<&str>, hard_delete: Option<&str>, user_delete_single_request: Option<models::UserDeleteSingleRequest>) -> Result<(), Error<DeleteUserWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_query_hard_delete = hard_delete;
    let p_body_user_delete_single_request = user_delete_single_request;

    let uri_str = format!("{}/api/user/{userId}", configuration.base_path, userId=crate::apis::urlencode(p_path_user_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_hard_delete {
        req_builder = req_builder.query(&[("hardDelete", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_user_delete_single_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteUserWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the WebAuthn credential for the given Id.
pub async fn delete_web_authn_credential_with_id(configuration: &configuration::Configuration, id: &str) -> Result<(), Error<DeleteWebAuthnCredentialWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/api/webauthn/{id}", configuration.base_path, id=crate::apis::urlencode(p_path_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteWebAuthnCredentialWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the webhook for the given Id.
pub async fn delete_webhook_with_id(configuration: &configuration::Configuration, webhook_id: &str) -> Result<(), Error<DeleteWebhookWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_webhook_id = webhook_id;

    let uri_str = format!("{}/api/webhook/{webhookId}", configuration.base_path, webhookId=crate::apis::urlencode(p_path_webhook_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteWebhookWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Enable two-factor authentication for a user.
pub async fn enable_two_factor_with_id(configuration: &configuration::Configuration, user_id: &str, two_factor_request: Option<models::TwoFactorRequest>) -> Result<models::TwoFactorResponse, Error<EnableTwoFactorWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_body_two_factor_request = two_factor_request;

    let uri_str = format!("{}/api/user/two-factor/{userId}", configuration.base_path, userId=crate::apis::urlencode(p_path_user_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_two_factor_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnableTwoFactorWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange a refresh token for a new JWT.
pub async fn exchange_refresh_token_for_jwt_with_id(configuration: &configuration::Configuration, refresh_request: Option<models::RefreshRequest>) -> Result<models::JwtRefreshResponse, Error<ExchangeRefreshTokenForJwtWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_refresh_request = refresh_request;

    let uri_str = format!("{}/api/jwt/refresh", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_refresh_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::JwtRefreshResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::JwtRefreshResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExchangeRefreshTokenForJwtWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Begins the forgot password sequence, which kicks off an email to the user so that they can reset their password.
pub async fn forgot_password_with_id(configuration: &configuration::Configuration, forgot_password_request: Option<models::ForgotPasswordRequest>) -> Result<models::ForgotPasswordResponse, Error<ForgotPasswordWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_forgot_password_request = forgot_password_request;

    let uri_str = format!("{}/api/user/forgot-password", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_forgot_password_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ForgotPasswordResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ForgotPasswordResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ForgotPasswordWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generate a new RSA or EC key pair or an HMAC secret.
pub async fn generate_key(configuration: &configuration::Configuration, key_request: Option<models::KeyRequest>) -> Result<models::KeyResponse, Error<GenerateKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_key_request = key_request;

    let uri_str = format!("{}/api/key/generate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_key_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::KeyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::KeyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GenerateKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generate a new RSA or EC key pair or an HMAC secret.
pub async fn generate_key_with_id(configuration: &configuration::Configuration, key_id: &str, key_request: Option<models::KeyRequest>) -> Result<models::KeyResponse, Error<GenerateKeyWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_key_id = key_id;
    let p_body_key_request = key_request;

    let uri_str = format!("{}/api/key/generate/{keyId}", configuration.base_path, keyId=crate::apis::urlencode(p_path_key_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_key_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::KeyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::KeyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GenerateKeyWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generate two-factor recovery codes for a user. Generating two-factor recovery codes will invalidate any existing recovery codes.
pub async fn generate_two_factor_recovery_codes_with_id(configuration: &configuration::Configuration, user_id: &str) -> Result<models::TwoFactorRecoveryCodeResponse, Error<GenerateTwoFactorRecoveryCodesWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;

    let uri_str = format!("{}/api/user/two-factor/recovery-code/{userId}", configuration.base_path, userId=crate::apis::urlencode(p_path_user_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorRecoveryCodeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorRecoveryCodeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GenerateTwoFactorRecoveryCodesWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generate a Two Factor secret that can be used to enable Two Factor authentication for a User. The response will contain both the secret and a Base32 encoded form of the secret which can be shown to a User when using a 2 Step Authentication application such as Google Authenticator.
pub async fn generate_two_factor_secret_using_jwt_with_id(configuration: &configuration::Configuration, ) -> Result<models::SecretResponse, Error<GenerateTwoFactorSecretUsingJwtWithIdError>> {

    let uri_str = format!("{}/api/two-factor/secret", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GenerateTwoFactorSecretUsingJwtWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Handles login via third-parties including Social login, external OAuth and OpenID Connect, and other login systems.
pub async fn identity_provider_login_with_id(configuration: &configuration::Configuration, x_fusion_auth_tenant_id: Option<&str>, identity_provider_login_request: Option<models::IdentityProviderLoginRequest>) -> Result<models::LoginResponse, Error<IdentityProviderLoginWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_identity_provider_login_request = identity_provider_login_request;

    let uri_str = format!("{}/api/identity-provider/login", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_identity_provider_login_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LoginResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LoginResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IdentityProviderLoginWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Import an existing RSA or EC key pair or an HMAC secret.
pub async fn import_key(configuration: &configuration::Configuration, key_request: Option<models::KeyRequest>) -> Result<models::KeyResponse, Error<ImportKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_key_request = key_request;

    let uri_str = format!("{}/api/key/import", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_key_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::KeyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::KeyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ImportKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Import an existing RSA or EC key pair or an HMAC secret.
pub async fn import_key_with_id(configuration: &configuration::Configuration, key_id: &str, key_request: Option<models::KeyRequest>) -> Result<models::KeyResponse, Error<ImportKeyWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_key_id = key_id;
    let p_body_key_request = key_request;

    let uri_str = format!("{}/api/key/import/{keyId}", configuration.base_path, keyId=crate::apis::urlencode(p_path_key_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_key_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::KeyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::KeyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ImportKeyWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Bulk imports refresh tokens. This request performs minimal validation and runs batch inserts of refresh tokens with the expectation that each token represents a user that already exists and is registered for the corresponding FusionAuth Application. This is done to increases the insert performance.  Therefore, if you encounter an error due to a database key violation, the response will likely offer a generic explanation. If you encounter an error, you may optionally enable additional validation to receive a JSON response body with specific validation errors. This will slow the request down but will allow you to identify the cause of the failure. See the validateDbConstraints request parameter.
pub async fn import_refresh_tokens_with_id(configuration: &configuration::Configuration, refresh_token_import_request: Option<models::RefreshTokenImportRequest>) -> Result<(), Error<ImportRefreshTokensWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_refresh_token_import_request = refresh_token_import_request;

    let uri_str = format!("{}/api/user/refresh-token/import", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_refresh_token_import_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ImportRefreshTokensWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Bulk imports users. This request performs minimal validation and runs batch inserts of users with the expectation that each user does not yet exist and each registration corresponds to an existing FusionAuth Application. This is done to increases the insert performance.  Therefore, if you encounter an error due to a database key violation, the response will likely offer a generic explanation. If you encounter an error, you may optionally enable additional validation to receive a JSON response body with specific validation errors. This will slow the request down but will allow you to identify the cause of the failure. See the validateDbConstraints request parameter.
pub async fn import_users_with_id(configuration: &configuration::Configuration, import_request: Option<models::ImportRequest>) -> Result<(), Error<ImportUsersWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_import_request = import_request;

    let uri_str = format!("{}/api/user/import", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_import_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ImportUsersWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Import a WebAuthn credential
pub async fn import_web_authn_credential_with_id(configuration: &configuration::Configuration, web_authn_credential_import_request: Option<models::WebAuthnCredentialImportRequest>) -> Result<(), Error<ImportWebAuthnCredentialWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_web_authn_credential_import_request = web_authn_credential_import_request;

    let uri_str = format!("{}/api/webauthn/import", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_web_authn_credential_import_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ImportWebAuthnCredentialWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Issue a new access token (JWT) for the requested Application after ensuring the provided JWT is valid. A valid access token is properly signed and not expired. <p> This API may be used in an SSO configuration to issue new tokens for another application after the user has obtained a valid token from authentication.
pub async fn issue_jwt_with_id(configuration: &configuration::Configuration, application_id: Option<&str>, refresh_token: Option<&str>) -> Result<models::IssueResponse, Error<IssueJwtWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_application_id = application_id;
    let p_query_refresh_token = refresh_token;

    let uri_str = format!("{}/api/jwt/issue", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_application_id {
        req_builder = req_builder.query(&[("applicationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_refresh_token {
        req_builder = req_builder.query(&[("refreshToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IssueResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IssueResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssueJwtWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sends a ping to FusionAuth indicating that the user was automatically logged into an application. When using FusionAuth's SSO or your own, you should call this if the user is already logged in centrally, but accesses an application where they no longer have a session. This helps correctly track login counts, times and helps with reporting.
pub async fn login_ping_with_id(configuration: &configuration::Configuration, user_id: &str, application_id: &str, caller_ip_address: Option<&str>, x_fusion_auth_tenant_id: Option<&str>) -> Result<models::LoginResponse, Error<LoginPingWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_path_application_id = application_id;
    let p_query_caller_ip_address = caller_ip_address;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/login/{userId}/{applicationId}", configuration.base_path, userId=crate::apis::urlencode(p_path_user_id), applicationId=crate::apis::urlencode(p_path_application_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_caller_ip_address {
        req_builder = req_builder.query(&[("callerIPAddress", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LoginResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LoginResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LoginPingWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sends a ping to FusionAuth indicating that the user was automatically logged into an application. When using FusionAuth's SSO or your own, you should call this if the user is already logged in centrally, but accesses an application where they no longer have a session. This helps correctly track login counts, times and helps with reporting.
pub async fn login_ping_with_request_with_id(configuration: &configuration::Configuration, x_fusion_auth_tenant_id: Option<&str>, login_ping_request: Option<models::LoginPingRequest>) -> Result<models::LoginResponse, Error<LoginPingWithRequestWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_login_ping_request = login_ping_request;

    let uri_str = format!("{}/api/login", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_login_ping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LoginResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LoginResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LoginPingWithRequestWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Authenticates a user to FusionAuth.   This API optionally requires an API key. See <code>Application.loginConfiguration.requireAuthentication</code>.
pub async fn login_with_id(configuration: &configuration::Configuration, x_fusion_auth_tenant_id: Option<&str>, login_request: Option<models::LoginRequest>) -> Result<models::LoginResponse, Error<LoginWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_login_request = login_request;

    let uri_str = format!("{}/api/login", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_login_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LoginResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LoginResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LoginWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the identity provider for the given domain. A 200 response code indicates the domain is managed by a registered identity provider. A 404 indicates the domain is not managed.
pub async fn lookup_identity_provider_with_id(configuration: &configuration::Configuration, domain: Option<&str>) -> Result<models::LookupResponse, Error<LookupIdentityProviderWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_domain = domain;

    let uri_str = format!("{}/api/identity-provider/lookup", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_domain {
        req_builder = req_builder.query(&[("domain", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LookupResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LookupResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LookupIdentityProviderWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Modifies a temporal user action by changing the expiration of the action and optionally adding a comment to the action.
pub async fn modify_action_with_id(configuration: &configuration::Configuration, action_id: &str, action_request: Option<models::ActionRequest>) -> Result<models::ActionResponse, Error<ModifyActionWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_action_id = action_id;
    let p_body_action_request = action_request;

    let uri_str = format!("{}/api/user/action/{actionId}", configuration.base_path, actionId=crate::apis::urlencode(p_path_action_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_action_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ActionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ActionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ModifyActionWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Complete a login request using a passwordless code
pub async fn passwordless_login_with_id(configuration: &configuration::Configuration, passwordless_login_request: Option<models::PasswordlessLoginRequest>) -> Result<models::LoginResponse, Error<PasswordlessLoginWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_passwordless_login_request = passwordless_login_request;

    let uri_str = format!("{}/api/passwordless/login", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_passwordless_login_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LoginResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LoginResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PasswordlessLoginWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates an API key with the given Id.
pub async fn patch_api_key_with_id(configuration: &configuration::Configuration, key_id: &str, api_key_request: Option<models::ApiKeyRequest>) -> Result<models::ApiKeyResponse, Error<PatchApiKeyWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_key_id = key_id;
    let p_body_api_key_request = api_key_request;

    let uri_str = format!("{}/api/api-key/{keyId}", configuration.base_path, keyId=crate::apis::urlencode(p_path_key_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_api_key_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiKeyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiKeyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchApiKeyWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, the application role with the given Id for the application.
pub async fn patch_application_role_with_id(configuration: &configuration::Configuration, application_id: &str, role_id: &str, x_fusion_auth_tenant_id: Option<&str>, application_request: Option<models::ApplicationRequest>) -> Result<models::ApplicationResponse, Error<PatchApplicationRoleWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_application_id = application_id;
    let p_path_role_id = role_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_application_request = application_request;

    let uri_str = format!("{}/api/application/{applicationId}/role/{roleId}", configuration.base_path, applicationId=crate::apis::urlencode(p_path_application_id), roleId=crate::apis::urlencode(p_path_role_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_application_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchApplicationRoleWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, the application with the given Id.
pub async fn patch_application_with_id(configuration: &configuration::Configuration, application_id: &str, x_fusion_auth_tenant_id: Option<&str>, application_request: Option<models::ApplicationRequest>) -> Result<models::ApplicationResponse, Error<PatchApplicationWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_application_id = application_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_application_request = application_request;

    let uri_str = format!("{}/api/application/{applicationId}", configuration.base_path, applicationId=crate::apis::urlencode(p_path_application_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_application_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchApplicationWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, the connector with the given Id.
pub async fn patch_connector_with_id(configuration: &configuration::Configuration, connector_id: &str, connector_request: Option<models::ConnectorRequest>) -> Result<models::ConnectorResponse, Error<PatchConnectorWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_connector_id = connector_id;
    let p_body_connector_request = connector_request;

    let uri_str = format!("{}/api/connector/{connectorId}", configuration.base_path, connectorId=crate::apis::urlencode(p_path_connector_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_connector_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConnectorResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConnectorResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchConnectorWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, the consent with the given Id.
pub async fn patch_consent_with_id(configuration: &configuration::Configuration, consent_id: &str, x_fusion_auth_tenant_id: Option<&str>, consent_request: Option<models::ConsentRequest>) -> Result<models::ConsentResponse, Error<PatchConsentWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_consent_id = consent_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_consent_request = consent_request;

    let uri_str = format!("{}/api/consent/{consentId}", configuration.base_path, consentId=crate::apis::urlencode(p_path_consent_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_consent_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConsentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConsentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchConsentWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, the email template with the given Id.
pub async fn patch_email_template_with_id(configuration: &configuration::Configuration, email_template_id: &str, x_fusion_auth_tenant_id: Option<&str>, email_template_request: Option<models::EmailTemplateRequest>) -> Result<models::EmailTemplateResponse, Error<PatchEmailTemplateWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_email_template_id = email_template_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_email_template_request = email_template_request;

    let uri_str = format!("{}/api/email/template/{emailTemplateId}", configuration.base_path, emailTemplateId=crate::apis::urlencode(p_path_email_template_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_email_template_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmailTemplateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmailTemplateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchEmailTemplateWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Patches the permission with the given Id for the entity type.
pub async fn patch_entity_type_permission_with_id(configuration: &configuration::Configuration, entity_type_id: &str, permission_id: &str, entity_type_request: Option<models::EntityTypeRequest>) -> Result<models::EntityTypeResponse, Error<PatchEntityTypePermissionWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_entity_type_id = entity_type_id;
    let p_path_permission_id = permission_id;
    let p_body_entity_type_request = entity_type_request;

    let uri_str = format!("{}/api/entity/type/{entityTypeId}/permission/{permissionId}", configuration.base_path, entityTypeId=crate::apis::urlencode(p_path_entity_type_id), permissionId=crate::apis::urlencode(p_path_permission_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_entity_type_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntityTypeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntityTypeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchEntityTypePermissionWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, the Entity Type with the given Id.
pub async fn patch_entity_type_with_id(configuration: &configuration::Configuration, entity_type_id: &str, entity_type_request: Option<models::EntityTypeRequest>) -> Result<models::EntityTypeResponse, Error<PatchEntityTypeWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_entity_type_id = entity_type_id;
    let p_body_entity_type_request = entity_type_request;

    let uri_str = format!("{}/api/entity/type/{entityTypeId}", configuration.base_path, entityTypeId=crate::apis::urlencode(p_path_entity_type_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_entity_type_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntityTypeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntityTypeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchEntityTypeWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, the Entity with the given Id.
pub async fn patch_entity_with_id(configuration: &configuration::Configuration, entity_id: &str, x_fusion_auth_tenant_id: Option<&str>, entity_request: Option<models::EntityRequest>) -> Result<models::EntityResponse, Error<PatchEntityWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_entity_id = entity_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_entity_request = entity_request;

    let uri_str = format!("{}/api/entity/{entityId}", configuration.base_path, entityId=crate::apis::urlencode(p_path_entity_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_entity_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntityResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntityResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchEntityWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Patches the form field with the given Id.
pub async fn patch_form_field_with_id(configuration: &configuration::Configuration, field_id: &str, form_field_request: Option<models::FormFieldRequest>) -> Result<models::FormFieldResponse, Error<PatchFormFieldWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_field_id = field_id;
    let p_body_form_field_request = form_field_request;

    let uri_str = format!("{}/api/form/field/{fieldId}", configuration.base_path, fieldId=crate::apis::urlencode(p_path_field_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_form_field_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FormFieldResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FormFieldResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchFormFieldWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Patches the form with the given Id.
pub async fn patch_form_with_id(configuration: &configuration::Configuration, form_id: &str, form_request: Option<models::FormRequest>) -> Result<models::FormResponse, Error<PatchFormWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_form_id = form_id;
    let p_body_form_request = form_request;

    let uri_str = format!("{}/api/form/{formId}", configuration.base_path, formId=crate::apis::urlencode(p_path_form_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_form_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FormResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FormResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchFormWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, the group with the given Id.
pub async fn patch_group_with_id(configuration: &configuration::Configuration, group_id: &str, x_fusion_auth_tenant_id: Option<&str>, group_request: Option<models::GroupRequest>) -> Result<models::GroupResponse, Error<PatchGroupWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_group_request = group_request;

    let uri_str = format!("{}/api/group/{groupId}", configuration.base_path, groupId=crate::apis::urlencode(p_path_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_group_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchGroupWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, the identity provider with the given Id.
pub async fn patch_identity_provider_with_id(configuration: &configuration::Configuration, identity_provider_id: &str, identity_provider_request: Option<models::IdentityProviderRequest>) -> Result<models::IdentityProviderResponse, Error<PatchIdentityProviderWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_identity_provider_id = identity_provider_id;
    let p_body_identity_provider_request = identity_provider_request;

    let uri_str = format!("{}/api/identity-provider/{identityProviderId}", configuration.base_path, identityProviderId=crate::apis::urlencode(p_path_identity_provider_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_identity_provider_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentityProviderResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentityProviderResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchIdentityProviderWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, the available integrations.
pub async fn patch_integrations_with_id(configuration: &configuration::Configuration, integration_request: Option<models::IntegrationRequest>) -> Result<models::IntegrationResponse, Error<PatchIntegrationsWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_integration_request = integration_request;

    let uri_str = format!("{}/api/integration", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_integration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IntegrationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IntegrationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchIntegrationsWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the IP Access Control List with the given Id.
pub async fn patch_ip_access_control_list_with_id(configuration: &configuration::Configuration, access_control_list_id: &str, ip_access_control_list_request: Option<models::IpAccessControlListRequest>) -> Result<models::IpAccessControlListResponse, Error<PatchIpAccessControlListWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_access_control_list_id = access_control_list_id;
    let p_body_ip_access_control_list_request = ip_access_control_list_request;

    let uri_str = format!("{}/api/ip-acl/{accessControlListId}", configuration.base_path, accessControlListId=crate::apis::urlencode(p_path_access_control_list_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_ip_access_control_list_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IpAccessControlListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IpAccessControlListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchIpAccessControlListWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, the lambda with the given Id.
pub async fn patch_lambda_with_id(configuration: &configuration::Configuration, lambda_id: &str, lambda_request: Option<models::LambdaRequest>) -> Result<models::LambdaResponse, Error<PatchLambdaWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_lambda_id = lambda_id;
    let p_body_lambda_request = lambda_request;

    let uri_str = format!("{}/api/lambda/{lambdaId}", configuration.base_path, lambdaId=crate::apis::urlencode(p_path_lambda_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_lambda_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LambdaResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LambdaResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchLambdaWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, the message template with the given Id.
pub async fn patch_message_template_with_id(configuration: &configuration::Configuration, message_template_id: &str, message_template_request: Option<models::MessageTemplateRequest>) -> Result<models::MessageTemplateResponse, Error<PatchMessageTemplateWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_message_template_id = message_template_id;
    let p_body_message_template_request = message_template_request;

    let uri_str = format!("{}/api/message/template/{messageTemplateId}", configuration.base_path, messageTemplateId=crate::apis::urlencode(p_path_message_template_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_message_template_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MessageTemplateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MessageTemplateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchMessageTemplateWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, the messenger with the given Id.
pub async fn patch_messenger_with_id(configuration: &configuration::Configuration, messenger_id: &str, messenger_request: Option<models::MessengerRequest>) -> Result<models::MessengerResponse, Error<PatchMessengerWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_messenger_id = messenger_id;
    let p_body_messenger_request = messenger_request;

    let uri_str = format!("{}/api/messenger/{messengerId}", configuration.base_path, messengerId=crate::apis::urlencode(p_path_messenger_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_messenger_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MessengerResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MessengerResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchMessengerWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, the custom OAuth scope with the given Id for the application.
pub async fn patch_o_auth_scope_with_id(configuration: &configuration::Configuration, application_id: &str, scope_id: &str, x_fusion_auth_tenant_id: Option<&str>, application_o_auth_scope_request: Option<models::ApplicationOAuthScopeRequest>) -> Result<models::ApplicationOAuthScopeResponse, Error<PatchOAuthScopeWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_application_id = application_id;
    let p_path_scope_id = scope_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_application_o_auth_scope_request = application_o_auth_scope_request;

    let uri_str = format!("{}/api/application/{applicationId}/scope/{scopeId}", configuration.base_path, applicationId=crate::apis::urlencode(p_path_application_id), scopeId=crate::apis::urlencode(p_path_scope_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_application_o_auth_scope_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationOAuthScopeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationOAuthScopeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchOAuthScopeWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, the registration for the user with the given Id and the application defined in the request.
pub async fn patch_registration_with_id(configuration: &configuration::Configuration, user_id: &str, x_fusion_auth_tenant_id: Option<&str>, registration_request: Option<models::RegistrationRequest>) -> Result<models::RegistrationResponse, Error<PatchRegistrationWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_registration_request = registration_request;

    let uri_str = format!("{}/api/user/registration/{userId}", configuration.base_path, userId=crate::apis::urlencode(p_path_user_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_registration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RegistrationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RegistrationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchRegistrationWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, the system configuration.
pub async fn patch_system_configuration_with_id(configuration: &configuration::Configuration, system_configuration_request: Option<models::SystemConfigurationRequest>) -> Result<models::SystemConfigurationResponse, Error<PatchSystemConfigurationWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_system_configuration_request = system_configuration_request;

    let uri_str = format!("{}/api/system-configuration", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_system_configuration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SystemConfigurationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SystemConfigurationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchSystemConfigurationWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, the tenant with the given Id.
pub async fn patch_tenant_with_id(configuration: &configuration::Configuration, tenant_id: &str, x_fusion_auth_tenant_id: Option<&str>, tenant_request: Option<models::TenantRequest>) -> Result<models::TenantResponse, Error<PatchTenantWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_tenant_id = tenant_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_tenant_request = tenant_request;

    let uri_str = format!("{}/api/tenant/{tenantId}", configuration.base_path, tenantId=crate::apis::urlencode(p_path_tenant_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_tenant_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TenantResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TenantResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchTenantWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, the theme with the given Id.
pub async fn patch_theme_with_id(configuration: &configuration::Configuration, theme_id: &str, theme_request: Option<models::ThemeRequest>) -> Result<models::ThemeResponse, Error<PatchThemeWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_theme_id = theme_id;
    let p_body_theme_request = theme_request;

    let uri_str = format!("{}/api/theme/{themeId}", configuration.base_path, themeId=crate::apis::urlencode(p_path_theme_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_theme_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ThemeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ThemeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchThemeWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, the user action reason with the given Id.
pub async fn patch_user_action_reason_with_id(configuration: &configuration::Configuration, user_action_reason_id: &str, user_action_reason_request: Option<models::UserActionReasonRequest>) -> Result<models::UserActionReasonResponse, Error<PatchUserActionReasonWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_action_reason_id = user_action_reason_id;
    let p_body_user_action_reason_request = user_action_reason_request;

    let uri_str = format!("{}/api/user-action-reason/{userActionReasonId}", configuration.base_path, userActionReasonId=crate::apis::urlencode(p_path_user_action_reason_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_user_action_reason_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserActionReasonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserActionReasonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchUserActionReasonWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, the user action with the given Id.
pub async fn patch_user_action_with_id(configuration: &configuration::Configuration, user_action_id: &str, x_fusion_auth_tenant_id: Option<&str>, user_action_request: Option<models::UserActionRequest>) -> Result<models::UserActionResponse, Error<PatchUserActionWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_action_id = user_action_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_user_action_request = user_action_request;

    let uri_str = format!("{}/api/user-action/{userActionId}", configuration.base_path, userActionId=crate::apis::urlencode(p_path_user_action_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_user_action_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserActionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserActionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchUserActionWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, a single User consent by Id.
pub async fn patch_user_consent_with_id(configuration: &configuration::Configuration, user_consent_id: &str, user_consent_request: Option<models::UserConsentRequest>) -> Result<models::UserConsentResponse, Error<PatchUserConsentWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_consent_id = user_consent_id;
    let p_body_user_consent_request = user_consent_request;

    let uri_str = format!("{}/api/user/consent/{userConsentId}", configuration.base_path, userConsentId=crate::apis::urlencode(p_path_user_consent_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_user_consent_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserConsentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserConsentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchUserConsentWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates, via PATCH, the user with the given Id.
pub async fn patch_user_with_id(configuration: &configuration::Configuration, user_id: &str, x_fusion_auth_tenant_id: Option<&str>, user_request: Option<models::UserRequest>) -> Result<models::UserResponse, Error<PatchUserWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_user_request = user_request;

    let uri_str = format!("{}/api/user/{userId}", configuration.base_path, userId=crate::apis::urlencode(p_path_user_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchUserWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Patches the webhook with the given Id.
pub async fn patch_webhook_with_id(configuration: &configuration::Configuration, webhook_id: &str, webhook_request: Option<models::WebhookRequest>) -> Result<models::WebhookResponse, Error<PatchWebhookWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_webhook_id = webhook_id;
    let p_body_webhook_request = webhook_request;

    let uri_str = format!("{}/api/webhook/{webhookId}", configuration.base_path, webhookId=crate::apis::urlencode(p_path_webhook_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_webhook_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebhookResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebhookResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchWebhookWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Reconcile a User to FusionAuth using JWT issued from another Identity Provider.
pub async fn reconcile_jwt_with_id(configuration: &configuration::Configuration, identity_provider_login_request: Option<models::IdentityProviderLoginRequest>) -> Result<models::LoginResponse, Error<ReconcileJwtWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_identity_provider_login_request = identity_provider_login_request;

    let uri_str = format!("{}/api/jwt/reconcile", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_identity_provider_login_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LoginResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LoginResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReconcileJwtWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Registers a user for an application. If you provide the User and the UserRegistration object on this request, it will create the user as well as register them for the application. This is called a Full Registration. However, if you only provide the UserRegistration object, then the user must already exist and they will be registered for the application. The user Id can also be provided and it will either be used to look up an existing user or it will be used for the newly created User.
pub async fn register(configuration: &configuration::Configuration, x_fusion_auth_tenant_id: Option<&str>, registration_request: Option<models::RegistrationRequest>) -> Result<models::RegistrationResponse, Error<RegisterError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_registration_request = registration_request;

    let uri_str = format!("{}/api/user/registration", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_registration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RegistrationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RegistrationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RegisterError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Registers a user for an application. If you provide the User and the UserRegistration object on this request, it will create the user as well as register them for the application. This is called a Full Registration. However, if you only provide the UserRegistration object, then the user must already exist and they will be registered for the application. The user Id can also be provided and it will either be used to look up an existing user or it will be used for the newly created User.
pub async fn register_with_id(configuration: &configuration::Configuration, user_id: &str, x_fusion_auth_tenant_id: Option<&str>, registration_request: Option<models::RegistrationRequest>) -> Result<models::RegistrationResponse, Error<RegisterWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_registration_request = registration_request;

    let uri_str = format!("{}/api/user/registration/{userId}", configuration.base_path, userId=crate::apis::urlencode(p_path_user_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_registration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RegistrationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RegistrationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RegisterWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Requests Elasticsearch to delete and rebuild the index for FusionAuth users or entities. Be very careful when running this request as it will  increase the CPU and I/O load on your database until the operation completes. Generally speaking you do not ever need to run this operation unless  instructed by FusionAuth support, or if you are migrating a database another system and you are not brining along the Elasticsearch index.   You have been warned.
pub async fn reindex_with_id(configuration: &configuration::Configuration, reindex_request: Option<models::ReindexRequest>) -> Result<(), Error<ReindexWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_reindex_request = reindex_request;

    let uri_str = format!("{}/api/system/reindex", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_reindex_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ReindexWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes a user from the family with the given Id.
pub async fn remove_user_from_family_with_id(configuration: &configuration::Configuration, family_id: &str, user_id: &str, x_fusion_auth_tenant_id: Option<&str>) -> Result<(), Error<RemoveUserFromFamilyWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_family_id = family_id;
    let p_path_user_id = user_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/user/family/{familyId}/{userId}", configuration.base_path, familyId=crate::apis::urlencode(p_path_family_id), userId=crate::apis::urlencode(p_path_user_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveUserFromFamilyWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a single action log (the log of a user action that was taken on a user previously) for the given Id.
pub async fn retrieve_action_with_id(configuration: &configuration::Configuration, action_id: &str) -> Result<models::ActionResponse, Error<RetrieveActionWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_action_id = action_id;

    let uri_str = format!("{}/api/user/action/{actionId}", configuration.base_path, actionId=crate::apis::urlencode(p_path_action_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ActionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ActionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveActionWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves an authentication API key for the given Id.
pub async fn retrieve_api_key_with_id(configuration: &configuration::Configuration, key_id: &str) -> Result<models::ApiKeyResponse, Error<RetrieveApiKeyWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_key_id = key_id;

    let uri_str = format!("{}/api/api-key/{keyId}", configuration.base_path, keyId=crate::apis::urlencode(p_path_key_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiKeyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiKeyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveApiKeyWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves all the applications that are currently inactive. OR Retrieves the application for the given Id or all the applications if the Id is null.
pub async fn retrieve_application(configuration: &configuration::Configuration, inactive: Option<&str>, x_fusion_auth_tenant_id: Option<&str>) -> Result<models::ApplicationResponse, Error<RetrieveApplicationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_inactive = inactive;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/application", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_inactive {
        req_builder = req_builder.query(&[("inactive", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveApplicationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the application for the given Id or all the applications if the Id is null.
pub async fn retrieve_application_with_id(configuration: &configuration::Configuration, application_id: &str, x_fusion_auth_tenant_id: Option<&str>) -> Result<models::ApplicationResponse, Error<RetrieveApplicationWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_application_id = application_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/application/{applicationId}", configuration.base_path, applicationId=crate::apis::urlencode(p_path_application_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveApplicationWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a single audit log for the given Id.
pub async fn retrieve_audit_log_with_id(configuration: &configuration::Configuration, audit_log_id: &str) -> Result<models::AuditLogResponse, Error<RetrieveAuditLogWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_audit_log_id = audit_log_id;

    let uri_str = format!("{}/api/system/audit-log/{auditLogId}", configuration.base_path, auditLogId=crate::apis::urlencode(p_path_audit_log_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuditLogResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuditLogResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveAuditLogWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the connector with the given Id.
pub async fn retrieve_connector_with_id(configuration: &configuration::Configuration, connector_id: &str) -> Result<models::ConnectorResponse, Error<RetrieveConnectorWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_connector_id = connector_id;

    let uri_str = format!("{}/api/connector/{connectorId}", configuration.base_path, connectorId=crate::apis::urlencode(p_path_connector_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConnectorResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConnectorResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveConnectorWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the Consent for the given Id.
pub async fn retrieve_consent_with_id(configuration: &configuration::Configuration, consent_id: &str, x_fusion_auth_tenant_id: Option<&str>) -> Result<models::ConsentResponse, Error<RetrieveConsentWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_consent_id = consent_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/consent/{consentId}", configuration.base_path, consentId=crate::apis::urlencode(p_path_consent_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConsentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConsentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveConsentWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the daily active user report between the two instants. If you specify an application Id, it will only return the daily active counts for that application.
pub async fn retrieve_daily_active_report_with_id(configuration: &configuration::Configuration, application_id: Option<&str>, start: Option<&str>, end: Option<&str>) -> Result<models::DailyActiveUserReportResponse, Error<RetrieveDailyActiveReportWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_application_id = application_id;
    let p_query_start = start;
    let p_query_end = end;

    let uri_str = format!("{}/api/report/daily-active-user", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_application_id {
        req_builder = req_builder.query(&[("applicationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DailyActiveUserReportResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DailyActiveUserReportResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveDailyActiveReportWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a user_code that is part of an in-progress Device Authorization Grant.  This API is useful if you want to build your own login workflow to complete a device grant.  This request will require an API key. OR Retrieve a user_code that is part of an in-progress Device Authorization Grant.  This API is useful if you want to build your own login workflow to complete a device grant.
pub async fn retrieve_device_user_code(configuration: &configuration::Configuration, ) -> Result<(), Error<RetrieveDeviceUserCodeError>> {

    let uri_str = format!("{}/oauth2/device/user-code", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveDeviceUserCodeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the email template for the given Id. If you don't specify the Id, this will return all the email templates.
pub async fn retrieve_email_template(configuration: &configuration::Configuration, x_fusion_auth_tenant_id: Option<&str>) -> Result<models::EmailTemplateResponse, Error<RetrieveEmailTemplateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/email/template", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmailTemplateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmailTemplateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveEmailTemplateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a preview of the email template provided in the request. This allows you to preview an email template that hasn't been saved to the database yet. The entire email template does not need to be provided on the request. This will create the preview based on whatever is given.
pub async fn retrieve_email_template_preview_with_id(configuration: &configuration::Configuration, preview_request: Option<models::PreviewRequest>) -> Result<models::PreviewResponse, Error<RetrieveEmailTemplatePreviewWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_preview_request = preview_request;

    let uri_str = format!("{}/api/email/template/preview", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_preview_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PreviewResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PreviewResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveEmailTemplatePreviewWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the email template for the given Id. If you don't specify the Id, this will return all the email templates.
pub async fn retrieve_email_template_with_id(configuration: &configuration::Configuration, email_template_id: &str, x_fusion_auth_tenant_id: Option<&str>) -> Result<models::EmailTemplateResponse, Error<RetrieveEmailTemplateWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_email_template_id = email_template_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/email/template/{emailTemplateId}", configuration.base_path, emailTemplateId=crate::apis::urlencode(p_path_email_template_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmailTemplateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmailTemplateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveEmailTemplateWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves an Entity Grant for the given Entity and User/Entity.
pub async fn retrieve_entity_grant_with_id(configuration: &configuration::Configuration, entity_id: &str, recipient_entity_id: Option<&str>, user_id: Option<&str>, x_fusion_auth_tenant_id: Option<&str>) -> Result<models::EntityGrantResponse, Error<RetrieveEntityGrantWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_entity_id = entity_id;
    let p_query_recipient_entity_id = recipient_entity_id;
    let p_query_user_id = user_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/entity/{entityId}/grant", configuration.base_path, entityId=crate::apis::urlencode(p_path_entity_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_recipient_entity_id {
        req_builder = req_builder.query(&[("recipientEntityId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("userId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntityGrantResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntityGrantResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveEntityGrantWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the Entity Type for the given Id.
pub async fn retrieve_entity_type_with_id(configuration: &configuration::Configuration, entity_type_id: &str) -> Result<models::EntityTypeResponse, Error<RetrieveEntityTypeWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_entity_type_id = entity_type_id;

    let uri_str = format!("{}/api/entity/type/{entityTypeId}", configuration.base_path, entityTypeId=crate::apis::urlencode(p_path_entity_type_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntityTypeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntityTypeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveEntityTypeWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the Entity for the given Id.
pub async fn retrieve_entity_with_id(configuration: &configuration::Configuration, entity_id: &str, x_fusion_auth_tenant_id: Option<&str>) -> Result<models::EntityResponse, Error<RetrieveEntityWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_entity_id = entity_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/entity/{entityId}", configuration.base_path, entityId=crate::apis::urlencode(p_path_entity_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntityResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntityResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveEntityWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a single event log for the given Id.
pub async fn retrieve_event_log_with_id(configuration: &configuration::Configuration, event_log_id: &str) -> Result<models::EventLogResponse, Error<RetrieveEventLogWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_event_log_id = event_log_id;

    let uri_str = format!("{}/api/system/event-log/{eventLogId}", configuration.base_path, eventLogId=crate::apis::urlencode(p_path_event_log_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EventLogResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EventLogResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveEventLogWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves all the families that a user belongs to.
pub async fn retrieve_families_with_id(configuration: &configuration::Configuration, user_id: Option<&str>, x_fusion_auth_tenant_id: Option<&str>) -> Result<models::FamilyResponse, Error<RetrieveFamiliesWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_user_id = user_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/user/family", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("userId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FamilyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FamilyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveFamiliesWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves all the members of a family by the unique Family Id.
pub async fn retrieve_family_members_by_family_id_with_id(configuration: &configuration::Configuration, family_id: &str, x_fusion_auth_tenant_id: Option<&str>) -> Result<models::FamilyResponse, Error<RetrieveFamilyMembersByFamilyIdWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_family_id = family_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/user/family/{familyId}", configuration.base_path, familyId=crate::apis::urlencode(p_path_family_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FamilyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FamilyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveFamilyMembersByFamilyIdWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the form field with the given Id.
pub async fn retrieve_form_field_with_id(configuration: &configuration::Configuration, field_id: &str) -> Result<models::FormFieldResponse, Error<RetrieveFormFieldWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_field_id = field_id;

    let uri_str = format!("{}/api/form/field/{fieldId}", configuration.base_path, fieldId=crate::apis::urlencode(p_path_field_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FormFieldResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FormFieldResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveFormFieldWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the form with the given Id.
pub async fn retrieve_form_with_id(configuration: &configuration::Configuration, form_id: &str) -> Result<models::FormResponse, Error<RetrieveFormWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_form_id = form_id;

    let uri_str = format!("{}/api/form/{formId}", configuration.base_path, formId=crate::apis::urlencode(p_path_form_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FormResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FormResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveFormWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the group for the given Id.
pub async fn retrieve_group_with_id(configuration: &configuration::Configuration, group_id: &str, x_fusion_auth_tenant_id: Option<&str>) -> Result<models::GroupResponse, Error<RetrieveGroupWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/group/{groupId}", configuration.base_path, groupId=crate::apis::urlencode(p_path_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveGroupWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves one or more identity provider for the given type. For types such as Google, Facebook, Twitter and LinkedIn, only a single  identity provider can exist. For types such as OpenID Connect and SAMLv2 more than one identity provider can be configured so this request  may return multiple identity providers.
pub async fn retrieve_identity_provider_by_type_with_id(configuration: &configuration::Configuration, r#type: Option<&str>) -> Result<models::IdentityProviderResponse, Error<RetrieveIdentityProviderByTypeWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_type = r#type;

    let uri_str = format!("{}/api/identity-provider", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentityProviderResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentityProviderResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveIdentityProviderByTypeWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve all Identity Provider users (links) for the user. Specify the optional identityProviderId to retrieve links for a particular IdP. OR Retrieve a single Identity Provider user (link).
pub async fn retrieve_identity_provider_link(configuration: &configuration::Configuration, identity_provider_id: Option<&str>, user_id: Option<&str>, identity_provider_user_id: Option<&str>) -> Result<models::IdentityProviderLinkResponse, Error<RetrieveIdentityProviderLinkError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_identity_provider_id = identity_provider_id;
    let p_query_user_id = user_id;
    let p_query_identity_provider_user_id = identity_provider_user_id;

    let uri_str = format!("{}/api/identity-provider/link", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_identity_provider_id {
        req_builder = req_builder.query(&[("identityProviderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("userId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_identity_provider_user_id {
        req_builder = req_builder.query(&[("identityProviderUserId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentityProviderLinkResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentityProviderLinkResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveIdentityProviderLinkError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the identity provider for the given Id or all the identity providers if the Id is null.
pub async fn retrieve_identity_provider_with_id(configuration: &configuration::Configuration, identity_provider_id: &str) -> Result<models::IdentityProviderResponse, Error<RetrieveIdentityProviderWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_identity_provider_id = identity_provider_id;

    let uri_str = format!("{}/api/identity-provider/{identityProviderId}", configuration.base_path, identityProviderId=crate::apis::urlencode(p_path_identity_provider_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentityProviderResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentityProviderResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveIdentityProviderWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the IP Access Control List with the given Id.
pub async fn retrieve_ip_access_control_list_with_id(configuration: &configuration::Configuration, ip_access_control_list_id: &str) -> Result<models::IpAccessControlListResponse, Error<RetrieveIpAccessControlListWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_ip_access_control_list_id = ip_access_control_list_id;

    let uri_str = format!("{}/api/ip-acl/{ipAccessControlListId}", configuration.base_path, ipAccessControlListId=crate::apis::urlencode(p_path_ip_access_control_list_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IpAccessControlListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IpAccessControlListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveIpAccessControlListWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns public keys used by FusionAuth to cryptographically verify JWTs using the JSON Web Key format.
pub async fn retrieve_json_web_key_set_with_id(configuration: &configuration::Configuration, ) -> Result<models::JwksResponse, Error<RetrieveJsonWebKeySetWithIdError>> {

    let uri_str = format!("{}/.well-known/jwks.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::JwksResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::JwksResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveJsonWebKeySetWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the Public Key configured for verifying the JSON Web Tokens (JWT) issued by the Login API by the Application Id. OR Retrieves the Public Key configured for verifying JSON Web Tokens (JWT) by the key Id (kid).
pub async fn retrieve_jwt_public_key(configuration: &configuration::Configuration, application_id: Option<&str>, key_id: Option<&str>) -> Result<models::PublicKeyResponse, Error<RetrieveJwtPublicKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_application_id = application_id;
    let p_query_key_id = key_id;

    let uri_str = format!("{}/api/jwt/public-key", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_application_id {
        req_builder = req_builder.query(&[("applicationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_key_id {
        req_builder = req_builder.query(&[("keyId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PublicKeyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PublicKeyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveJwtPublicKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the key for the given Id.
pub async fn retrieve_key_with_id(configuration: &configuration::Configuration, key_id: &str) -> Result<models::KeyResponse, Error<RetrieveKeyWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_key_id = key_id;

    let uri_str = format!("{}/api/key/{keyId}", configuration.base_path, keyId=crate::apis::urlencode(p_path_key_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::KeyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::KeyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveKeyWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves all the keys.
pub async fn retrieve_keys_with_id(configuration: &configuration::Configuration, ) -> Result<models::KeyResponse, Error<RetrieveKeysWithIdError>> {

    let uri_str = format!("{}/api/key", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::KeyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::KeyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveKeysWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the lambda for the given Id.
pub async fn retrieve_lambda_with_id(configuration: &configuration::Configuration, lambda_id: &str) -> Result<models::LambdaResponse, Error<RetrieveLambdaWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_lambda_id = lambda_id;

    let uri_str = format!("{}/api/lambda/{lambdaId}", configuration.base_path, lambdaId=crate::apis::urlencode(p_path_lambda_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LambdaResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LambdaResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveLambdaWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves all the lambdas for the provided type.
pub async fn retrieve_lambdas_by_type_with_id(configuration: &configuration::Configuration, r#type: Option<&str>) -> Result<models::LambdaResponse, Error<RetrieveLambdasByTypeWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_type = r#type;

    let uri_str = format!("{}/api/lambda", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LambdaResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LambdaResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveLambdasByTypeWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the message template for the given Id. If you don't specify the Id, this will return all the message templates.
pub async fn retrieve_message_template(configuration: &configuration::Configuration, ) -> Result<models::MessageTemplateResponse, Error<RetrieveMessageTemplateError>> {

    let uri_str = format!("{}/api/message/template", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MessageTemplateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MessageTemplateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveMessageTemplateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a preview of the message template provided in the request, normalized to a given locale.
pub async fn retrieve_message_template_preview_with_id(configuration: &configuration::Configuration, preview_message_template_request: Option<models::PreviewMessageTemplateRequest>) -> Result<models::PreviewMessageTemplateResponse, Error<RetrieveMessageTemplatePreviewWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_preview_message_template_request = preview_message_template_request;

    let uri_str = format!("{}/api/message/template/preview", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_preview_message_template_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PreviewMessageTemplateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PreviewMessageTemplateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveMessageTemplatePreviewWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the message template for the given Id. If you don't specify the Id, this will return all the message templates.
pub async fn retrieve_message_template_with_id(configuration: &configuration::Configuration, message_template_id: &str) -> Result<models::MessageTemplateResponse, Error<RetrieveMessageTemplateWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_message_template_id = message_template_id;

    let uri_str = format!("{}/api/message/template/{messageTemplateId}", configuration.base_path, messageTemplateId=crate::apis::urlencode(p_path_message_template_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MessageTemplateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MessageTemplateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveMessageTemplateWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the messenger with the given Id.
pub async fn retrieve_messenger_with_id(configuration: &configuration::Configuration, messenger_id: &str) -> Result<models::MessengerResponse, Error<RetrieveMessengerWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_messenger_id = messenger_id;

    let uri_str = format!("{}/api/messenger/{messengerId}", configuration.base_path, messengerId=crate::apis::urlencode(p_path_messenger_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MessengerResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MessengerResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveMessengerWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the monthly active user report between the two instants. If you specify an application Id, it will only return the monthly active counts for that application.
pub async fn retrieve_monthly_active_report_with_id(configuration: &configuration::Configuration, application_id: Option<&str>, start: Option<&str>, end: Option<&str>) -> Result<models::MonthlyActiveUserReportResponse, Error<RetrieveMonthlyActiveReportWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_application_id = application_id;
    let p_query_start = start;
    let p_query_end = end;

    let uri_str = format!("{}/api/report/monthly-active-user", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_application_id {
        req_builder = req_builder.query(&[("applicationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MonthlyActiveUserReportResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MonthlyActiveUserReportResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveMonthlyActiveReportWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a custom OAuth scope.
pub async fn retrieve_o_auth_scope_with_id(configuration: &configuration::Configuration, application_id: &str, scope_id: &str, x_fusion_auth_tenant_id: Option<&str>) -> Result<models::ApplicationOAuthScopeResponse, Error<RetrieveOAuthScopeWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_application_id = application_id;
    let p_path_scope_id = scope_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/application/{applicationId}/scope/{scopeId}", configuration.base_path, applicationId=crate::apis::urlencode(p_path_application_id), scopeId=crate::apis::urlencode(p_path_scope_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationOAuthScopeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationOAuthScopeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveOAuthScopeWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the Oauth2 configuration for the application for the given Application Id.
pub async fn retrieve_oauth_configuration_with_id(configuration: &configuration::Configuration, application_id: &str, x_fusion_auth_tenant_id: Option<&str>) -> Result<models::OAuthConfigurationResponse, Error<RetrieveOauthConfigurationWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_application_id = application_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/application/{applicationId}/oauth-configuration", configuration.base_path, applicationId=crate::apis::urlencode(p_path_application_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OAuthConfigurationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OAuthConfigurationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveOauthConfigurationWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the well known OpenID Configuration JSON document
pub async fn retrieve_open_id_configuration_with_id(configuration: &configuration::Configuration, ) -> Result<models::OpenIdConfiguration, Error<RetrieveOpenIdConfigurationWithIdError>> {

    let uri_str = format!("{}/.well-known/openid-configuration", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OpenIdConfiguration`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OpenIdConfiguration`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveOpenIdConfigurationWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the password validation rules for a specific tenant. This method requires a tenantId to be provided  through the use of a Tenant scoped API key or an HTTP header X-FusionAuth-TenantId to specify the Tenant Id.  This API does not require an API key.
pub async fn retrieve_password_validation_rules_with_id(configuration: &configuration::Configuration, ) -> Result<models::PasswordValidationRulesResponse, Error<RetrievePasswordValidationRulesWithIdError>> {

    let uri_str = format!("{}/api/tenant/password-validation-rules", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PasswordValidationRulesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PasswordValidationRulesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrievePasswordValidationRulesWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the password validation rules for a specific tenant.  This API does not require an API key.
pub async fn retrieve_password_validation_rules_with_tenant_id_with_id(configuration: &configuration::Configuration, tenant_id: &str) -> Result<models::PasswordValidationRulesResponse, Error<RetrievePasswordValidationRulesWithTenantIdWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_tenant_id = tenant_id;

    let uri_str = format!("{}/api/tenant/password-validation-rules/{tenantId}", configuration.base_path, tenantId=crate::apis::urlencode(p_path_tenant_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PasswordValidationRulesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PasswordValidationRulesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrievePasswordValidationRulesWithTenantIdWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves all the children for the given parent email address.
pub async fn retrieve_pending_children_with_id(configuration: &configuration::Configuration, parent_email: Option<&str>) -> Result<models::PendingResponse, Error<RetrievePendingChildrenWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_parent_email = parent_email;

    let uri_str = format!("{}/api/user/family/pending", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_parent_email {
        req_builder = req_builder.query(&[("parentEmail", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PendingResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PendingResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrievePendingChildrenWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a pending identity provider link. This is useful to validate a pending link and retrieve meta-data about the identity provider link.
pub async fn retrieve_pending_link_with_id(configuration: &configuration::Configuration, pending_link_id: &str, user_id: Option<&str>) -> Result<models::IdentityProviderPendingLinkResponse, Error<RetrievePendingLinkWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pending_link_id = pending_link_id;
    let p_query_user_id = user_id;

    let uri_str = format!("{}/api/identity-provider/link/pending/{pendingLinkId}", configuration.base_path, pendingLinkId=crate::apis::urlencode(p_path_pending_link_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("userId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentityProviderPendingLinkResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentityProviderPendingLinkResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrievePendingLinkWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the FusionAuth Reactor metrics.
pub async fn retrieve_reactor_metrics_with_id(configuration: &configuration::Configuration, ) -> Result<models::ReactorMetricsResponse, Error<RetrieveReactorMetricsWithIdError>> {

    let uri_str = format!("{}/api/reactor/metrics", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReactorMetricsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReactorMetricsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveReactorMetricsWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a single refresh token by unique Id. This is not the same thing as the string value of the refresh token. If you have that, you already have what you need.
pub async fn retrieve_refresh_token_by_id_with_id(configuration: &configuration::Configuration, token_id: &str) -> Result<models::RefreshTokenResponse, Error<RetrieveRefreshTokenByIdWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_token_id = token_id;

    let uri_str = format!("{}/api/jwt/refresh/{tokenId}", configuration.base_path, tokenId=crate::apis::urlencode(p_path_token_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RefreshTokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RefreshTokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveRefreshTokenByIdWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the refresh tokens that belong to the user with the given Id.
pub async fn retrieve_refresh_tokens_with_id(configuration: &configuration::Configuration, user_id: Option<&str>) -> Result<models::RefreshTokenResponse, Error<RetrieveRefreshTokensWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_user_id = user_id;

    let uri_str = format!("{}/api/jwt/refresh", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("userId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RefreshTokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RefreshTokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveRefreshTokensWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the registration report between the two instants. If you specify an application Id, it will only return the registration counts for that application.
pub async fn retrieve_registration_report_with_id(configuration: &configuration::Configuration, application_id: Option<&str>, start: Option<&str>, end: Option<&str>) -> Result<models::RegistrationReportResponse, Error<RetrieveRegistrationReportWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_application_id = application_id;
    let p_query_start = start;
    let p_query_end = end;

    let uri_str = format!("{}/api/report/registration", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_application_id {
        req_builder = req_builder.query(&[("applicationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RegistrationReportResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RegistrationReportResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveRegistrationReportWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the user registration for the user with the given Id and the given application Id.
pub async fn retrieve_registration_with_id(configuration: &configuration::Configuration, user_id: &str, application_id: &str, x_fusion_auth_tenant_id: Option<&str>) -> Result<models::RegistrationResponse, Error<RetrieveRegistrationWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_path_application_id = application_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/user/registration/{userId}/{applicationId}", configuration.base_path, userId=crate::apis::urlencode(p_path_user_id), applicationId=crate::apis::urlencode(p_path_application_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RegistrationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RegistrationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveRegistrationWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the login report between the two instants for a particular user by login Id, using specific loginIdTypes. If you specify an application id, it will only return the login counts for that application. OR Retrieves the login report between the two instants for a particular user by login Id. If you specify an application Id, it will only return the login counts for that application. OR Retrieves the login report between the two instants for a particular user by Id. If you specify an application Id, it will only return the login counts for that application. OR Retrieves the login report between the two instants. If you specify an application Id, it will only return the login counts for that application.
pub async fn retrieve_report_login(configuration: &configuration::Configuration, application_id: Option<&str>, login_id: Option<&str>, start: Option<&str>, end: Option<&str>, login_id_types: Option<Vec<String>>, user_id: Option<&str>) -> Result<models::LoginReportResponse, Error<RetrieveReportLoginError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_application_id = application_id;
    let p_query_login_id = login_id;
    let p_query_start = start;
    let p_query_end = end;
    let p_query_login_id_types = login_id_types;
    let p_query_user_id = user_id;

    let uri_str = format!("{}/api/report/login", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_application_id {
        req_builder = req_builder.query(&[("applicationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_login_id {
        req_builder = req_builder.query(&[("loginId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_login_id_types {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("loginIdTypes".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("loginIdTypes", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("userId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LoginReportResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LoginReportResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveReportLoginError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the FusionAuth system status using an API key. Using an API key will cause the response to include the product version, health checks and various runtime metrics. OR Retrieves the FusionAuth system status. This request is anonymous and does not require an API key. When an API key is not provided the response will contain a single value in the JSON response indicating the current health check.
pub async fn retrieve_status(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<RetrieveStatusError>> {

    let uri_str = format!("{}/api/status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the FusionAuth system health. This API will return 200 if the system is healthy, and 500 if the system is un-healthy.
pub async fn retrieve_system_health_with_id(configuration: &configuration::Configuration, ) -> Result<(), Error<RetrieveSystemHealthWithIdError>> {

    let uri_str = format!("{}/api/health", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveSystemHealthWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the tenant for the given Id.
pub async fn retrieve_tenant_with_id(configuration: &configuration::Configuration, tenant_id: &str, x_fusion_auth_tenant_id: Option<&str>) -> Result<models::TenantResponse, Error<RetrieveTenantWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_tenant_id = tenant_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/tenant/{tenantId}", configuration.base_path, tenantId=crate::apis::urlencode(p_path_tenant_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TenantResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TenantResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveTenantWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the theme for the given Id.
pub async fn retrieve_theme_with_id(configuration: &configuration::Configuration, theme_id: &str) -> Result<models::ThemeResponse, Error<RetrieveThemeWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_theme_id = theme_id;

    let uri_str = format!("{}/api/theme/{themeId}", configuration.base_path, themeId=crate::apis::urlencode(p_path_theme_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ThemeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ThemeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveThemeWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the totals report. This contains all the total counts for each application and the global registration count.
pub async fn retrieve_total_report_with_id(configuration: &configuration::Configuration, ) -> Result<models::TotalsReportResponse, Error<RetrieveTotalReportWithIdError>> {

    let uri_str = format!("{}/api/report/totals", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TotalsReportResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TotalsReportResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveTotalReportWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve two-factor recovery codes for a user.
pub async fn retrieve_two_factor_recovery_codes_with_id(configuration: &configuration::Configuration, user_id: &str) -> Result<models::TwoFactorRecoveryCodeResponse, Error<RetrieveTwoFactorRecoveryCodesWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;

    let uri_str = format!("{}/api/user/two-factor/recovery-code/{userId}", configuration.base_path, userId=crate::apis::urlencode(p_path_user_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorRecoveryCodeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorRecoveryCodeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveTwoFactorRecoveryCodesWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a user's two-factor status.  This can be used to see if a user will need to complete a two-factor challenge to complete a login, and optionally identify the state of the two-factor trust across various applications.
pub async fn retrieve_two_factor_status_with_id(configuration: &configuration::Configuration, two_factor_trust_id: &str, user_id: Option<&str>, application_id: Option<&str>) -> Result<models::TwoFactorStatusResponse, Error<RetrieveTwoFactorStatusWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_two_factor_trust_id = two_factor_trust_id;
    let p_query_user_id = user_id;
    let p_query_application_id = application_id;

    let uri_str = format!("{}/api/two-factor/status/{twoFactorTrustId}", configuration.base_path, twoFactorTrustId=crate::apis::urlencode(p_path_two_factor_trust_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("userId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_application_id {
        req_builder = req_builder.query(&[("applicationId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorStatusResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorStatusResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveTwoFactorStatusWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the user for the given Id. This method does not use an API key, instead it uses a JSON Web Token (JWT) for authentication. OR Retrieves the user by a verificationId. The intended use of this API is to retrieve a user after the forgot password workflow has been initiated and you may not know the user's email or username. OR Retrieves the user for the given username. OR Retrieves the user for the loginId, using specific loginIdTypes. OR Retrieves the user for the loginId. The loginId can be either the username or the email. OR Retrieves the user for the given email. OR Retrieves the user by a change password Id. The intended use of this API is to retrieve a user after the forgot password workflow has been initiated and you may not know the user's email or username.
pub async fn retrieve_user(configuration: &configuration::Configuration, x_fusion_auth_tenant_id: Option<&str>, verification_id: Option<&str>, username: Option<&str>, login_id: Option<&str>, login_id_types: Option<Vec<String>>, email: Option<&str>, change_password_id: Option<&str>) -> Result<models::UserResponse, Error<RetrieveUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_query_verification_id = verification_id;
    let p_query_username = username;
    let p_query_login_id = login_id;
    let p_query_login_id_types = login_id_types;
    let p_query_email = email;
    let p_query_change_password_id = change_password_id;

    let uri_str = format!("{}/api/user", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_verification_id {
        req_builder = req_builder.query(&[("verificationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_login_id {
        req_builder = req_builder.query(&[("loginId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_login_id_types {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("loginIdTypes".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("loginIdTypes", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_email {
        req_builder = req_builder.query(&[("email", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_change_password_id {
        req_builder = req_builder.query(&[("changePasswordId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the user action for the given Id. If you pass in null for the Id, this will return all the user actions. OR Retrieves all the user actions that are currently inactive.
pub async fn retrieve_user_action(configuration: &configuration::Configuration, x_fusion_auth_tenant_id: Option<&str>, inactive: Option<&str>) -> Result<models::UserActionResponse, Error<RetrieveUserActionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_query_inactive = inactive;

    let uri_str = format!("{}/api/user-action", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_inactive {
        req_builder = req_builder.query(&[("inactive", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserActionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserActionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveUserActionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the user action reason for the given Id. If you pass in null for the Id, this will return all the user action reasons.
pub async fn retrieve_user_action_reason(configuration: &configuration::Configuration, ) -> Result<models::UserActionReasonResponse, Error<RetrieveUserActionReasonError>> {

    let uri_str = format!("{}/api/user-action-reason", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserActionReasonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserActionReasonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveUserActionReasonError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the user action reason for the given Id. If you pass in null for the Id, this will return all the user action reasons.
pub async fn retrieve_user_action_reason_with_id(configuration: &configuration::Configuration, user_action_reason_id: &str) -> Result<models::UserActionReasonResponse, Error<RetrieveUserActionReasonWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_action_reason_id = user_action_reason_id;

    let uri_str = format!("{}/api/user-action-reason/{userActionReasonId}", configuration.base_path, userActionReasonId=crate::apis::urlencode(p_path_user_action_reason_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserActionReasonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserActionReasonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveUserActionReasonWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the user action for the given Id. If you pass in null for the Id, this will return all the user actions.
pub async fn retrieve_user_action_with_id(configuration: &configuration::Configuration, user_action_id: &str, x_fusion_auth_tenant_id: Option<&str>) -> Result<models::UserActionResponse, Error<RetrieveUserActionWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_action_id = user_action_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/user-action/{userActionId}", configuration.base_path, userActionId=crate::apis::urlencode(p_path_user_action_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserActionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserActionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveUserActionWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves all the actions for the user with the given Id that are currently inactive. An inactive action means one that is time based and has been canceled or has expired, or is not time based. OR Retrieves all the actions for the user with the given Id that are currently active. An active action means one that is time based and has not been canceled, and has not ended. OR Retrieves all the actions for the user with the given Id that are currently preventing the User from logging in. OR Retrieves all the actions for the user with the given Id. This will return all time based actions that are active, and inactive as well as non-time based actions.
pub async fn retrieve_user_actioning(configuration: &configuration::Configuration, user_id: Option<&str>, active: Option<&str>, preventing_login: Option<&str>) -> Result<models::ActionResponse, Error<RetrieveUserActioningError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_user_id = user_id;
    let p_query_active = active;
    let p_query_preventing_login = preventing_login;

    let uri_str = format!("{}/api/user/action", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("userId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_active {
        req_builder = req_builder.query(&[("active", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preventing_login {
        req_builder = req_builder.query(&[("preventingLogin", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ActionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ActionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveUserActioningError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Check to see if the user must obtain a Trust Request Id in order to complete a change password request. When a user has enabled Two-Factor authentication, before you are allowed to use the Change Password API to change your password, you must obtain a Trust Request Id by completing a Two-Factor Step-Up authentication.  An HTTP status code of 400 with a general error code of [TrustTokenRequired] indicates that a Trust Token is required to make a POST request to this API. OR Check to see if the user must obtain a Trust Token Id in order to complete a change password request. When a user has enabled Two-Factor authentication, before you are allowed to use the Change Password API to change your password, you must obtain a Trust Token by completing a Two-Factor Step-Up authentication.  An HTTP status code of 400 with a general error code of [TrustTokenRequired] indicates that a Trust Token is required to make a POST request to this API.
pub async fn retrieve_user_change_password(configuration: &configuration::Configuration, login_id: Option<&str>) -> Result<(), Error<RetrieveUserChangePasswordError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_login_id = login_id;

    let uri_str = format!("{}/api/user/change-password", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_login_id {
        req_builder = req_builder.query(&[("loginId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveUserChangePasswordError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves all the comments for the user with the given Id.
pub async fn retrieve_user_comments_with_id(configuration: &configuration::Configuration, user_id: &str, x_fusion_auth_tenant_id: Option<&str>) -> Result<models::UserCommentResponse, Error<RetrieveUserCommentsWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/user/comment/{userId}", configuration.base_path, userId=crate::apis::urlencode(p_path_user_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserCommentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserCommentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveUserCommentsWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a single User consent by Id.
pub async fn retrieve_user_consent_with_id(configuration: &configuration::Configuration, user_consent_id: &str) -> Result<models::UserConsentResponse, Error<RetrieveUserConsentWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_consent_id = user_consent_id;

    let uri_str = format!("{}/api/user/consent/{userConsentId}", configuration.base_path, userConsentId=crate::apis::urlencode(p_path_user_consent_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserConsentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserConsentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveUserConsentWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves all the consents for a User.
pub async fn retrieve_user_consents_with_id(configuration: &configuration::Configuration, user_id: Option<&str>) -> Result<models::UserConsentResponse, Error<RetrieveUserConsentsWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_user_id = user_id;

    let uri_str = format!("{}/api/user/consent", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("userId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserConsentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserConsentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveUserConsentsWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Call the UserInfo endpoint to retrieve User Claims from the access token issued by FusionAuth.
pub async fn retrieve_user_info_from_access_token_with_id(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<RetrieveUserInfoFromAccessTokenWithIdError>> {

    let uri_str = format!("{}/oauth2/userinfo", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveUserInfoFromAccessTokenWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the last number of login records for a user. OR Retrieves the last number of login records.
pub async fn retrieve_user_recent_login(configuration: &configuration::Configuration, user_id: Option<&str>, offset: Option<&str>, limit: Option<&str>) -> Result<models::RecentLoginResponse, Error<RetrieveUserRecentLoginError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_user_id = user_id;
    let p_query_offset = offset;
    let p_query_limit = limit;

    let uri_str = format!("{}/api/user/recent-login", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("userId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RecentLoginResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RecentLoginResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveUserRecentLoginError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the user for the given Id.
pub async fn retrieve_user_with_id(configuration: &configuration::Configuration, user_id: &str, x_fusion_auth_tenant_id: Option<&str>) -> Result<models::UserResponse, Error<RetrieveUserWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;

    let uri_str = format!("{}/api/user/{userId}", configuration.base_path, userId=crate::apis::urlencode(p_path_user_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveUserWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the FusionAuth version string.
pub async fn retrieve_version_with_id(configuration: &configuration::Configuration, ) -> Result<models::VersionResponse, Error<RetrieveVersionWithIdError>> {

    let uri_str = format!("{}/api/system/version", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VersionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VersionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveVersionWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the WebAuthn credential for the given Id.
pub async fn retrieve_web_authn_credential_with_id(configuration: &configuration::Configuration, id: &str) -> Result<models::WebAuthnCredentialResponse, Error<RetrieveWebAuthnCredentialWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/api/webauthn/{id}", configuration.base_path, id=crate::apis::urlencode(p_path_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebAuthnCredentialResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebAuthnCredentialResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveWebAuthnCredentialWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves all WebAuthn credentials for the given user.
pub async fn retrieve_web_authn_credentials_for_user_with_id(configuration: &configuration::Configuration, user_id: Option<&str>) -> Result<models::WebAuthnCredentialResponse, Error<RetrieveWebAuthnCredentialsForUserWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_user_id = user_id;

    let uri_str = format!("{}/api/webauthn", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("userId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebAuthnCredentialResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebAuthnCredentialResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveWebAuthnCredentialsForUserWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the webhook for the given Id. If you pass in null for the Id, this will return all the webhooks.
pub async fn retrieve_webhook(configuration: &configuration::Configuration, ) -> Result<models::WebhookResponse, Error<RetrieveWebhookError>> {

    let uri_str = format!("{}/api/webhook", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebhookResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebhookResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveWebhookError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a single webhook attempt log for the given Id.
pub async fn retrieve_webhook_attempt_log_with_id(configuration: &configuration::Configuration, webhook_attempt_log_id: &str) -> Result<models::WebhookAttemptLogResponse, Error<RetrieveWebhookAttemptLogWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_webhook_attempt_log_id = webhook_attempt_log_id;

    let uri_str = format!("{}/api/system/webhook-attempt-log/{webhookAttemptLogId}", configuration.base_path, webhookAttemptLogId=crate::apis::urlencode(p_path_webhook_attempt_log_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebhookAttemptLogResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebhookAttemptLogResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveWebhookAttemptLogWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a single webhook event log for the given Id.
pub async fn retrieve_webhook_event_log_with_id(configuration: &configuration::Configuration, webhook_event_log_id: &str) -> Result<models::WebhookEventLogResponse, Error<RetrieveWebhookEventLogWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_webhook_event_log_id = webhook_event_log_id;

    let uri_str = format!("{}/api/system/webhook-event-log/{webhookEventLogId}", configuration.base_path, webhookEventLogId=crate::apis::urlencode(p_path_webhook_event_log_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebhookEventLogResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebhookEventLogResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveWebhookEventLogWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the webhook for the given Id. If you pass in null for the Id, this will return all the webhooks.
pub async fn retrieve_webhook_with_id(configuration: &configuration::Configuration, webhook_id: &str) -> Result<models::WebhookResponse, Error<RetrieveWebhookWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_webhook_id = webhook_id;

    let uri_str = format!("{}/api/webhook/{webhookId}", configuration.base_path, webhookId=crate::apis::urlencode(p_path_webhook_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebhookResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebhookResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveWebhookWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Revokes a single refresh token by the unique Id. The unique Id is not sensitive as it cannot be used to obtain another JWT.
pub async fn revoke_refresh_token_by_id_with_id(configuration: &configuration::Configuration, token_id: &str) -> Result<(), Error<RevokeRefreshTokenByIdWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_token_id = token_id;

    let uri_str = format!("{}/api/jwt/refresh/{tokenId}", configuration.base_path, tokenId=crate::apis::urlencode(p_path_token_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RevokeRefreshTokenByIdWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Revokes a single User consent by Id.
pub async fn revoke_user_consent_with_id(configuration: &configuration::Configuration, user_consent_id: &str) -> Result<(), Error<RevokeUserConsentWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_consent_id = user_consent_id;

    let uri_str = format!("{}/api/user/consent/{userConsentId}", configuration.base_path, userConsentId=crate::apis::urlencode(p_path_user_consent_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RevokeUserConsentWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches applications with the specified criteria and pagination.
pub async fn search_applications_with_id(configuration: &configuration::Configuration, application_search_request: Option<models::ApplicationSearchRequest>) -> Result<models::ApplicationSearchResponse, Error<SearchApplicationsWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_application_search_request = application_search_request;

    let uri_str = format!("{}/api/application/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_application_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchApplicationsWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches the audit logs with the specified criteria and pagination.
pub async fn search_audit_logs_with_id(configuration: &configuration::Configuration, audit_log_search_request: Option<models::AuditLogSearchRequest>) -> Result<models::AuditLogSearchResponse, Error<SearchAuditLogsWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_audit_log_search_request = audit_log_search_request;

    let uri_str = format!("{}/api/system/audit-log/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_audit_log_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuditLogSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuditLogSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchAuditLogsWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches consents with the specified criteria and pagination.
pub async fn search_consents_with_id(configuration: &configuration::Configuration, consent_search_request: Option<models::ConsentSearchRequest>) -> Result<models::ConsentSearchResponse, Error<SearchConsentsWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_consent_search_request = consent_search_request;

    let uri_str = format!("{}/api/consent/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_consent_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConsentSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConsentSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchConsentsWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches email templates with the specified criteria and pagination.
pub async fn search_email_templates_with_id(configuration: &configuration::Configuration, email_template_search_request: Option<models::EmailTemplateSearchRequest>) -> Result<models::EmailTemplateSearchResponse, Error<SearchEmailTemplatesWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_email_template_search_request = email_template_search_request;

    let uri_str = format!("{}/api/email/template/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_email_template_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmailTemplateSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmailTemplateSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchEmailTemplatesWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the entities for the given Ids. If any Id is invalid, it is ignored.
pub async fn search_entities_by_ids_with_id(configuration: &configuration::Configuration, ids: Option<&str>) -> Result<models::EntitySearchResponse, Error<SearchEntitiesByIdsWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_ids = ids;

    let uri_str = format!("{}/api/entity/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_ids {
        req_builder = req_builder.query(&[("ids", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntitySearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntitySearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchEntitiesByIdsWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches entities with the specified criteria and pagination.
pub async fn search_entities_with_id(configuration: &configuration::Configuration, entity_search_request: Option<models::EntitySearchRequest>) -> Result<models::EntitySearchResponse, Error<SearchEntitiesWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_entity_search_request = entity_search_request;

    let uri_str = format!("{}/api/entity/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_entity_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntitySearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntitySearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchEntitiesWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches Entity Grants with the specified criteria and pagination.
pub async fn search_entity_grants_with_id(configuration: &configuration::Configuration, entity_grant_search_request: Option<models::EntityGrantSearchRequest>) -> Result<models::EntityGrantSearchResponse, Error<SearchEntityGrantsWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_entity_grant_search_request = entity_grant_search_request;

    let uri_str = format!("{}/api/entity/grant/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_entity_grant_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntityGrantSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntityGrantSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchEntityGrantsWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches the entity types with the specified criteria and pagination.
pub async fn search_entity_types_with_id(configuration: &configuration::Configuration, entity_type_search_request: Option<models::EntityTypeSearchRequest>) -> Result<models::EntityTypeSearchResponse, Error<SearchEntityTypesWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_entity_type_search_request = entity_type_search_request;

    let uri_str = format!("{}/api/entity/type/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_entity_type_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntityTypeSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntityTypeSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchEntityTypesWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches the event logs with the specified criteria and pagination.
pub async fn search_event_logs_with_id(configuration: &configuration::Configuration, event_log_search_request: Option<models::EventLogSearchRequest>) -> Result<models::EventLogSearchResponse, Error<SearchEventLogsWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_event_log_search_request = event_log_search_request;

    let uri_str = format!("{}/api/system/event-log/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_event_log_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EventLogSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EventLogSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchEventLogsWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches group members with the specified criteria and pagination.
pub async fn search_group_members_with_id(configuration: &configuration::Configuration, group_member_search_request: Option<models::GroupMemberSearchRequest>) -> Result<models::GroupMemberSearchResponse, Error<SearchGroupMembersWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_group_member_search_request = group_member_search_request;

    let uri_str = format!("{}/api/group/member/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_group_member_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupMemberSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupMemberSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchGroupMembersWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches groups with the specified criteria and pagination.
pub async fn search_groups_with_id(configuration: &configuration::Configuration, group_search_request: Option<models::GroupSearchRequest>) -> Result<models::GroupSearchResponse, Error<SearchGroupsWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_group_search_request = group_search_request;

    let uri_str = format!("{}/api/group/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_group_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchGroupsWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches identity providers with the specified criteria and pagination.
pub async fn search_identity_providers_with_id(configuration: &configuration::Configuration, identity_provider_search_request: Option<models::IdentityProviderSearchRequest>) -> Result<models::IdentityProviderSearchResponse, Error<SearchIdentityProvidersWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_identity_provider_search_request = identity_provider_search_request;

    let uri_str = format!("{}/api/identity-provider/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_identity_provider_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentityProviderSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentityProviderSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchIdentityProvidersWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches the IP Access Control Lists with the specified criteria and pagination.
pub async fn search_ip_access_control_lists_with_id(configuration: &configuration::Configuration, ip_access_control_list_search_request: Option<models::IpAccessControlListSearchRequest>) -> Result<models::IpAccessControlListSearchResponse, Error<SearchIpAccessControlListsWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_ip_access_control_list_search_request = ip_access_control_list_search_request;

    let uri_str = format!("{}/api/ip-acl/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_ip_access_control_list_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IpAccessControlListSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IpAccessControlListSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchIpAccessControlListsWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches keys with the specified criteria and pagination.
pub async fn search_keys_with_id(configuration: &configuration::Configuration, key_search_request: Option<models::KeySearchRequest>) -> Result<models::KeySearchResponse, Error<SearchKeysWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_key_search_request = key_search_request;

    let uri_str = format!("{}/api/key/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_key_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::KeySearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::KeySearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchKeysWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches lambdas with the specified criteria and pagination.
pub async fn search_lambdas_with_id(configuration: &configuration::Configuration, lambda_search_request: Option<models::LambdaSearchRequest>) -> Result<models::LambdaSearchResponse, Error<SearchLambdasWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_lambda_search_request = lambda_search_request;

    let uri_str = format!("{}/api/lambda/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_lambda_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LambdaSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LambdaSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchLambdasWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches the login records with the specified criteria and pagination.
pub async fn search_login_records_with_id(configuration: &configuration::Configuration, login_record_search_request: Option<models::LoginRecordSearchRequest>) -> Result<models::LoginRecordSearchResponse, Error<SearchLoginRecordsWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_login_record_search_request = login_record_search_request;

    let uri_str = format!("{}/api/system/login-record/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_login_record_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LoginRecordSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LoginRecordSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchLoginRecordsWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches tenants with the specified criteria and pagination.
pub async fn search_tenants_with_id(configuration: &configuration::Configuration, tenant_search_request: Option<models::TenantSearchRequest>) -> Result<models::TenantSearchResponse, Error<SearchTenantsWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_tenant_search_request = tenant_search_request;

    let uri_str = format!("{}/api/tenant/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_tenant_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TenantSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TenantSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchTenantsWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches themes with the specified criteria and pagination.
pub async fn search_themes_with_id(configuration: &configuration::Configuration, theme_search_request: Option<models::ThemeSearchRequest>) -> Result<models::ThemeSearchResponse, Error<SearchThemesWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_theme_search_request = theme_search_request;

    let uri_str = format!("{}/api/theme/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_theme_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ThemeSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ThemeSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchThemesWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches user comments with the specified criteria and pagination.
pub async fn search_user_comments_with_id(configuration: &configuration::Configuration, user_comment_search_request: Option<models::UserCommentSearchRequest>) -> Result<models::UserCommentSearchResponse, Error<SearchUserCommentsWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_user_comment_search_request = user_comment_search_request;

    let uri_str = format!("{}/api/user/comment/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_user_comment_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserCommentSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserCommentSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchUserCommentsWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the users for the given Ids. If any Id is invalid, it is ignored.
pub async fn search_users_by_ids_with_id(configuration: &configuration::Configuration, ids: Option<&str>) -> Result<models::SearchResponse, Error<SearchUsersByIdsWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_ids = ids;

    let uri_str = format!("{}/api/user/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_ids {
        req_builder = req_builder.query(&[("ids", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchUsersByIdsWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the users for the given search criteria and pagination.
pub async fn search_users_by_query_with_id(configuration: &configuration::Configuration, search_request: Option<models::SearchRequest>) -> Result<models::SearchResponse, Error<SearchUsersByQueryWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_search_request = search_request;

    let uri_str = format!("{}/api/user/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchUsersByQueryWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches the webhook event logs with the specified criteria and pagination.
pub async fn search_webhook_event_logs_with_id(configuration: &configuration::Configuration, webhook_event_log_search_request: Option<models::WebhookEventLogSearchRequest>) -> Result<models::WebhookEventLogSearchResponse, Error<SearchWebhookEventLogsWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_webhook_event_log_search_request = webhook_event_log_search_request;

    let uri_str = format!("{}/api/system/webhook-event-log/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_webhook_event_log_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebhookEventLogSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebhookEventLogSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchWebhookEventLogsWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches webhooks with the specified criteria and pagination.
pub async fn search_webhooks_with_id(configuration: &configuration::Configuration, webhook_search_request: Option<models::WebhookSearchRequest>) -> Result<models::WebhookSearchResponse, Error<SearchWebhooksWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_webhook_search_request = webhook_search_request;

    let uri_str = format!("{}/api/webhook/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_webhook_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebhookSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebhookSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchWebhooksWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send an email using an email template Id. You can optionally provide <code>requestData</code> to access key value pairs in the email template.
pub async fn send_email_with_id(configuration: &configuration::Configuration, email_template_id: &str, send_request: Option<models::SendRequest>) -> Result<models::SendResponse, Error<SendEmailWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_email_template_id = email_template_id;
    let p_body_send_request = send_request;

    let uri_str = format!("{}/api/email/send/{emailTemplateId}", configuration.base_path, emailTemplateId=crate::apis::urlencode(p_path_email_template_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_send_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SendResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SendResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SendEmailWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sends out an email to a parent that they need to register and create a family or need to log in and add a child to their existing family.
pub async fn send_family_request_email_with_id(configuration: &configuration::Configuration, family_email_request: Option<models::FamilyEmailRequest>) -> Result<(), Error<SendFamilyRequestEmailWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_family_email_request = family_email_request;

    let uri_str = format!("{}/api/user/family/request", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_family_email_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SendFamilyRequestEmailWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send a passwordless authentication code in an email to complete login.
pub async fn send_passwordless_code_with_id(configuration: &configuration::Configuration, passwordless_send_request: Option<models::PasswordlessSendRequest>) -> Result<(), Error<SendPasswordlessCodeWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_passwordless_send_request = passwordless_send_request;

    let uri_str = format!("{}/api/passwordless/send", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_passwordless_send_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SendPasswordlessCodeWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send a Two Factor authentication code to assist in setting up Two Factor authentication or disabling.
pub async fn send_two_factor_code_for_enable_disable_with_id(configuration: &configuration::Configuration, two_factor_send_request: Option<models::TwoFactorSendRequest>) -> Result<(), Error<SendTwoFactorCodeForEnableDisableWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_two_factor_send_request = two_factor_send_request;

    let uri_str = format!("{}/api/two-factor/send", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_two_factor_send_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SendTwoFactorCodeForEnableDisableWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send a Two Factor authentication code to allow the completion of Two Factor authentication.
pub async fn send_two_factor_code_for_login_using_method_with_id(configuration: &configuration::Configuration, two_factor_id: &str, two_factor_send_request: Option<models::TwoFactorSendRequest>) -> Result<(), Error<SendTwoFactorCodeForLoginUsingMethodWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_two_factor_id = two_factor_id;
    let p_body_two_factor_send_request = two_factor_send_request;

    let uri_str = format!("{}/api/two-factor/send/{twoFactorId}", configuration.base_path, twoFactorId=crate::apis::urlencode(p_path_two_factor_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_two_factor_send_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SendTwoFactorCodeForLoginUsingMethodWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send a verification code using the appropriate transport for the identity type being verified.
pub async fn send_verify_identity_with_id(configuration: &configuration::Configuration, verify_send_request: Option<models::VerifySendRequest>) -> Result<(), Error<SendVerifyIdentityWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_verify_send_request = verify_send_request;

    let uri_str = format!("{}/api/identity/verify/send", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_verify_send_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SendVerifyIdentityWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Begins a login request for a 3rd party login that requires user interaction such as HYPR.
pub async fn start_identity_provider_login_with_id(configuration: &configuration::Configuration, identity_provider_start_login_request: Option<models::IdentityProviderStartLoginRequest>) -> Result<models::IdentityProviderStartLoginResponse, Error<StartIdentityProviderLoginWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_identity_provider_start_login_request = identity_provider_start_login_request;

    let uri_str = format!("{}/api/identity-provider/start", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_identity_provider_start_login_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentityProviderStartLoginResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentityProviderStartLoginResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StartIdentityProviderLoginWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start a passwordless login request by generating a passwordless code. This code can be sent to the User using the Send Passwordless Code API or using a mechanism outside of FusionAuth. The passwordless login is completed by using the Passwordless Login API with this code.
pub async fn start_passwordless_login_with_id(configuration: &configuration::Configuration, passwordless_start_request: Option<models::PasswordlessStartRequest>) -> Result<models::PasswordlessStartResponse, Error<StartPasswordlessLoginWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_passwordless_start_request = passwordless_start_request;

    let uri_str = format!("{}/api/passwordless/start", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_passwordless_start_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PasswordlessStartResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PasswordlessStartResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StartPasswordlessLoginWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start a Two-Factor login request by generating a two-factor identifier. This code can then be sent to the Two Factor Send  API (/api/two-factor/send)in order to send a one-time use code to a user. You can also use one-time use code returned  to send the code out-of-band. The Two-Factor login is completed by making a request to the Two-Factor Login  API (/api/two-factor/login). with the two-factor identifier and the one-time use code.  This API is intended to allow you to begin a Two-Factor login outside a normal login that originated from the Login API (/api/login).
pub async fn start_two_factor_login_with_id(configuration: &configuration::Configuration, two_factor_start_request: Option<models::TwoFactorStartRequest>) -> Result<models::TwoFactorStartResponse, Error<StartTwoFactorLoginWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_two_factor_start_request = two_factor_start_request;

    let uri_str = format!("{}/api/two-factor/start", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_two_factor_start_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorStartResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorStartResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StartTwoFactorLoginWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start a verification of an identity by generating a code. This code can be sent to the User using the Verify Send API Verification Code API or using a mechanism outside of FusionAuth. The verification is completed by using the Verify Complete API with this code.
pub async fn start_verify_identity_with_id(configuration: &configuration::Configuration, verify_start_request: Option<models::VerifyStartRequest>) -> Result<models::VerifyStartResponse, Error<StartVerifyIdentityWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_verify_start_request = verify_start_request;

    let uri_str = format!("{}/api/identity/verify/start", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_verify_start_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VerifyStartResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VerifyStartResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StartVerifyIdentityWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start a WebAuthn authentication ceremony by generating a new challenge for the user
pub async fn start_web_authn_login_with_id(configuration: &configuration::Configuration, web_authn_start_request: Option<models::WebAuthnStartRequest>) -> Result<models::WebAuthnStartResponse, Error<StartWebAuthnLoginWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_web_authn_start_request = web_authn_start_request;

    let uri_str = format!("{}/api/webauthn/start", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_web_authn_start_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebAuthnStartResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebAuthnStartResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StartWebAuthnLoginWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start a WebAuthn registration ceremony by generating a new challenge for the user
pub async fn start_web_authn_registration_with_id(configuration: &configuration::Configuration, web_authn_register_start_request: Option<models::WebAuthnRegisterStartRequest>) -> Result<models::WebAuthnRegisterStartResponse, Error<StartWebAuthnRegistrationWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_web_authn_register_start_request = web_authn_register_start_request;

    let uri_str = format!("{}/api/webauthn/register/start", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_web_authn_register_start_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebAuthnRegisterStartResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebAuthnRegisterStartResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StartWebAuthnRegistrationWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Complete login using a 2FA challenge
pub async fn two_factor_login_with_id(configuration: &configuration::Configuration, two_factor_login_request: Option<models::TwoFactorLoginRequest>) -> Result<models::LoginResponse, Error<TwoFactorLoginWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_two_factor_login_request = two_factor_login_request;

    let uri_str = format!("{}/api/two-factor/login", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_two_factor_login_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LoginResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LoginResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorLoginWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates an API key with the given Id.
pub async fn update_api_key_with_id(configuration: &configuration::Configuration, key_id: &str, api_key_request: Option<models::ApiKeyRequest>) -> Result<models::ApiKeyResponse, Error<UpdateApiKeyWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_key_id = key_id;
    let p_body_api_key_request = api_key_request;

    let uri_str = format!("{}/api/api-key/{keyId}", configuration.base_path, keyId=crate::apis::urlencode(p_path_key_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_api_key_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiKeyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiKeyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateApiKeyWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the application role with the given Id for the application.
pub async fn update_application_role_with_id(configuration: &configuration::Configuration, application_id: &str, role_id: &str, x_fusion_auth_tenant_id: Option<&str>, application_request: Option<models::ApplicationRequest>) -> Result<models::ApplicationResponse, Error<UpdateApplicationRoleWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_application_id = application_id;
    let p_path_role_id = role_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_application_request = application_request;

    let uri_str = format!("{}/api/application/{applicationId}/role/{roleId}", configuration.base_path, applicationId=crate::apis::urlencode(p_path_application_id), roleId=crate::apis::urlencode(p_path_role_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_application_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateApplicationRoleWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the application with the given Id. OR Reactivates the application with the given Id.
pub async fn update_application_with_id(configuration: &configuration::Configuration, application_id: &str, x_fusion_auth_tenant_id: Option<&str>, reactivate: Option<&str>, application_request: Option<models::ApplicationRequest>) -> Result<models::ApplicationResponse, Error<UpdateApplicationWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_application_id = application_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_query_reactivate = reactivate;
    let p_body_application_request = application_request;

    let uri_str = format!("{}/api/application/{applicationId}", configuration.base_path, applicationId=crate::apis::urlencode(p_path_application_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_reactivate {
        req_builder = req_builder.query(&[("reactivate", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_application_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateApplicationWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the connector with the given Id.
pub async fn update_connector_with_id(configuration: &configuration::Configuration, connector_id: &str, connector_request: Option<models::ConnectorRequest>) -> Result<models::ConnectorResponse, Error<UpdateConnectorWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_connector_id = connector_id;
    let p_body_connector_request = connector_request;

    let uri_str = format!("{}/api/connector/{connectorId}", configuration.base_path, connectorId=crate::apis::urlencode(p_path_connector_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_connector_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConnectorResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConnectorResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateConnectorWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the consent with the given Id.
pub async fn update_consent_with_id(configuration: &configuration::Configuration, consent_id: &str, x_fusion_auth_tenant_id: Option<&str>, consent_request: Option<models::ConsentRequest>) -> Result<models::ConsentResponse, Error<UpdateConsentWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_consent_id = consent_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_consent_request = consent_request;

    let uri_str = format!("{}/api/consent/{consentId}", configuration.base_path, consentId=crate::apis::urlencode(p_path_consent_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_consent_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConsentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConsentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateConsentWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the email template with the given Id.
pub async fn update_email_template_with_id(configuration: &configuration::Configuration, email_template_id: &str, x_fusion_auth_tenant_id: Option<&str>, email_template_request: Option<models::EmailTemplateRequest>) -> Result<models::EmailTemplateResponse, Error<UpdateEmailTemplateWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_email_template_id = email_template_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_email_template_request = email_template_request;

    let uri_str = format!("{}/api/email/template/{emailTemplateId}", configuration.base_path, emailTemplateId=crate::apis::urlencode(p_path_email_template_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_email_template_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmailTemplateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmailTemplateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateEmailTemplateWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the permission with the given Id for the entity type.
pub async fn update_entity_type_permission_with_id(configuration: &configuration::Configuration, entity_type_id: &str, permission_id: &str, entity_type_request: Option<models::EntityTypeRequest>) -> Result<models::EntityTypeResponse, Error<UpdateEntityTypePermissionWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_entity_type_id = entity_type_id;
    let p_path_permission_id = permission_id;
    let p_body_entity_type_request = entity_type_request;

    let uri_str = format!("{}/api/entity/type/{entityTypeId}/permission/{permissionId}", configuration.base_path, entityTypeId=crate::apis::urlencode(p_path_entity_type_id), permissionId=crate::apis::urlencode(p_path_permission_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_entity_type_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntityTypeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntityTypeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateEntityTypePermissionWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the Entity Type with the given Id.
pub async fn update_entity_type_with_id(configuration: &configuration::Configuration, entity_type_id: &str, entity_type_request: Option<models::EntityTypeRequest>) -> Result<models::EntityTypeResponse, Error<UpdateEntityTypeWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_entity_type_id = entity_type_id;
    let p_body_entity_type_request = entity_type_request;

    let uri_str = format!("{}/api/entity/type/{entityTypeId}", configuration.base_path, entityTypeId=crate::apis::urlencode(p_path_entity_type_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_entity_type_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntityTypeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntityTypeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateEntityTypeWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the Entity with the given Id.
pub async fn update_entity_with_id(configuration: &configuration::Configuration, entity_id: &str, x_fusion_auth_tenant_id: Option<&str>, entity_request: Option<models::EntityRequest>) -> Result<models::EntityResponse, Error<UpdateEntityWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_entity_id = entity_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_entity_request = entity_request;

    let uri_str = format!("{}/api/entity/{entityId}", configuration.base_path, entityId=crate::apis::urlencode(p_path_entity_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_entity_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntityResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntityResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateEntityWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the form field with the given Id.
pub async fn update_form_field_with_id(configuration: &configuration::Configuration, field_id: &str, form_field_request: Option<models::FormFieldRequest>) -> Result<models::FormFieldResponse, Error<UpdateFormFieldWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_field_id = field_id;
    let p_body_form_field_request = form_field_request;

    let uri_str = format!("{}/api/form/field/{fieldId}", configuration.base_path, fieldId=crate::apis::urlencode(p_path_field_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_form_field_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FormFieldResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FormFieldResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateFormFieldWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the form with the given Id.
pub async fn update_form_with_id(configuration: &configuration::Configuration, form_id: &str, form_request: Option<models::FormRequest>) -> Result<models::FormResponse, Error<UpdateFormWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_form_id = form_id;
    let p_body_form_request = form_request;

    let uri_str = format!("{}/api/form/{formId}", configuration.base_path, formId=crate::apis::urlencode(p_path_form_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_form_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FormResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FormResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateFormWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a member in a group.
pub async fn update_group_members_with_id(configuration: &configuration::Configuration, member_request: Option<models::MemberRequest>) -> Result<models::MemberResponse, Error<UpdateGroupMembersWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_member_request = member_request;

    let uri_str = format!("{}/api/group/member", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_member_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MemberResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MemberResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateGroupMembersWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the group with the given Id.
pub async fn update_group_with_id(configuration: &configuration::Configuration, group_id: &str, x_fusion_auth_tenant_id: Option<&str>, group_request: Option<models::GroupRequest>) -> Result<models::GroupResponse, Error<UpdateGroupWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_group_request = group_request;

    let uri_str = format!("{}/api/group/{groupId}", configuration.base_path, groupId=crate::apis::urlencode(p_path_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_group_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateGroupWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the identity provider with the given Id.
pub async fn update_identity_provider_with_id(configuration: &configuration::Configuration, identity_provider_id: &str, identity_provider_request: Option<models::IdentityProviderRequest>) -> Result<models::IdentityProviderResponse, Error<UpdateIdentityProviderWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_identity_provider_id = identity_provider_id;
    let p_body_identity_provider_request = identity_provider_request;

    let uri_str = format!("{}/api/identity-provider/{identityProviderId}", configuration.base_path, identityProviderId=crate::apis::urlencode(p_path_identity_provider_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_identity_provider_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentityProviderResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentityProviderResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateIdentityProviderWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the available integrations.
pub async fn update_integrations_with_id(configuration: &configuration::Configuration, integration_request: Option<models::IntegrationRequest>) -> Result<models::IntegrationResponse, Error<UpdateIntegrationsWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_integration_request = integration_request;

    let uri_str = format!("{}/api/integration", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_integration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IntegrationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IntegrationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateIntegrationsWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the IP Access Control List with the given Id.
pub async fn update_ip_access_control_list_with_id(configuration: &configuration::Configuration, access_control_list_id: &str, ip_access_control_list_request: Option<models::IpAccessControlListRequest>) -> Result<models::IpAccessControlListResponse, Error<UpdateIpAccessControlListWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_access_control_list_id = access_control_list_id;
    let p_body_ip_access_control_list_request = ip_access_control_list_request;

    let uri_str = format!("{}/api/ip-acl/{accessControlListId}", configuration.base_path, accessControlListId=crate::apis::urlencode(p_path_access_control_list_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_ip_access_control_list_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IpAccessControlListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IpAccessControlListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateIpAccessControlListWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the key with the given Id.
pub async fn update_key_with_id(configuration: &configuration::Configuration, key_id: &str, key_request: Option<models::KeyRequest>) -> Result<models::KeyResponse, Error<UpdateKeyWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_key_id = key_id;
    let p_body_key_request = key_request;

    let uri_str = format!("{}/api/key/{keyId}", configuration.base_path, keyId=crate::apis::urlencode(p_path_key_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_key_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::KeyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::KeyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateKeyWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the lambda with the given Id.
pub async fn update_lambda_with_id(configuration: &configuration::Configuration, lambda_id: &str, lambda_request: Option<models::LambdaRequest>) -> Result<models::LambdaResponse, Error<UpdateLambdaWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_lambda_id = lambda_id;
    let p_body_lambda_request = lambda_request;

    let uri_str = format!("{}/api/lambda/{lambdaId}", configuration.base_path, lambdaId=crate::apis::urlencode(p_path_lambda_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_lambda_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LambdaResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LambdaResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateLambdaWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the message template with the given Id.
pub async fn update_message_template_with_id(configuration: &configuration::Configuration, message_template_id: &str, message_template_request: Option<models::MessageTemplateRequest>) -> Result<models::MessageTemplateResponse, Error<UpdateMessageTemplateWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_message_template_id = message_template_id;
    let p_body_message_template_request = message_template_request;

    let uri_str = format!("{}/api/message/template/{messageTemplateId}", configuration.base_path, messageTemplateId=crate::apis::urlencode(p_path_message_template_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_message_template_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MessageTemplateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MessageTemplateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateMessageTemplateWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the messenger with the given Id.
pub async fn update_messenger_with_id(configuration: &configuration::Configuration, messenger_id: &str, messenger_request: Option<models::MessengerRequest>) -> Result<models::MessengerResponse, Error<UpdateMessengerWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_messenger_id = messenger_id;
    let p_body_messenger_request = messenger_request;

    let uri_str = format!("{}/api/messenger/{messengerId}", configuration.base_path, messengerId=crate::apis::urlencode(p_path_messenger_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_messenger_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MessengerResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MessengerResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateMessengerWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the OAuth scope with the given Id for the application.
pub async fn update_o_auth_scope_with_id(configuration: &configuration::Configuration, application_id: &str, scope_id: &str, x_fusion_auth_tenant_id: Option<&str>, application_o_auth_scope_request: Option<models::ApplicationOAuthScopeRequest>) -> Result<models::ApplicationOAuthScopeResponse, Error<UpdateOAuthScopeWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_application_id = application_id;
    let p_path_scope_id = scope_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_application_o_auth_scope_request = application_o_auth_scope_request;

    let uri_str = format!("{}/api/application/{applicationId}/scope/{scopeId}", configuration.base_path, applicationId=crate::apis::urlencode(p_path_application_id), scopeId=crate::apis::urlencode(p_path_scope_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_application_o_auth_scope_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationOAuthScopeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationOAuthScopeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateOAuthScopeWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the registration for the user with the given Id and the application defined in the request.
pub async fn update_registration_with_id(configuration: &configuration::Configuration, user_id: &str, x_fusion_auth_tenant_id: Option<&str>, registration_request: Option<models::RegistrationRequest>) -> Result<models::RegistrationResponse, Error<UpdateRegistrationWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_registration_request = registration_request;

    let uri_str = format!("{}/api/user/registration/{userId}", configuration.base_path, userId=crate::apis::urlencode(p_path_user_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_registration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RegistrationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RegistrationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateRegistrationWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the system configuration.
pub async fn update_system_configuration_with_id(configuration: &configuration::Configuration, system_configuration_request: Option<models::SystemConfigurationRequest>) -> Result<models::SystemConfigurationResponse, Error<UpdateSystemConfigurationWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_system_configuration_request = system_configuration_request;

    let uri_str = format!("{}/api/system-configuration", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_system_configuration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SystemConfigurationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SystemConfigurationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateSystemConfigurationWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the tenant with the given Id.
pub async fn update_tenant_with_id(configuration: &configuration::Configuration, tenant_id: &str, x_fusion_auth_tenant_id: Option<&str>, tenant_request: Option<models::TenantRequest>) -> Result<models::TenantResponse, Error<UpdateTenantWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_tenant_id = tenant_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_tenant_request = tenant_request;

    let uri_str = format!("{}/api/tenant/{tenantId}", configuration.base_path, tenantId=crate::apis::urlencode(p_path_tenant_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_tenant_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TenantResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TenantResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateTenantWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the theme with the given Id.
pub async fn update_theme_with_id(configuration: &configuration::Configuration, theme_id: &str, theme_request: Option<models::ThemeRequest>) -> Result<models::ThemeResponse, Error<UpdateThemeWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_theme_id = theme_id;
    let p_body_theme_request = theme_request;

    let uri_str = format!("{}/api/theme/{themeId}", configuration.base_path, themeId=crate::apis::urlencode(p_path_theme_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_theme_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ThemeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ThemeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateThemeWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the user action reason with the given Id.
pub async fn update_user_action_reason_with_id(configuration: &configuration::Configuration, user_action_reason_id: &str, user_action_reason_request: Option<models::UserActionReasonRequest>) -> Result<models::UserActionReasonResponse, Error<UpdateUserActionReasonWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_action_reason_id = user_action_reason_id;
    let p_body_user_action_reason_request = user_action_reason_request;

    let uri_str = format!("{}/api/user-action-reason/{userActionReasonId}", configuration.base_path, userActionReasonId=crate::apis::urlencode(p_path_user_action_reason_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_user_action_reason_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserActionReasonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserActionReasonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUserActionReasonWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the user action with the given Id. OR Reactivates the user action with the given Id.
pub async fn update_user_action_with_id(configuration: &configuration::Configuration, user_action_id: &str, x_fusion_auth_tenant_id: Option<&str>, reactivate: Option<&str>, user_action_request: Option<models::UserActionRequest>) -> Result<models::UserActionResponse, Error<UpdateUserActionWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_action_id = user_action_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_query_reactivate = reactivate;
    let p_body_user_action_request = user_action_request;

    let uri_str = format!("{}/api/user-action/{userActionId}", configuration.base_path, userActionId=crate::apis::urlencode(p_path_user_action_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_reactivate {
        req_builder = req_builder.query(&[("reactivate", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_user_action_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserActionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserActionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUserActionWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates a single User consent by Id.
pub async fn update_user_consent_with_id(configuration: &configuration::Configuration, user_consent_id: &str, user_consent_request: Option<models::UserConsentRequest>) -> Result<models::UserConsentResponse, Error<UpdateUserConsentWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_consent_id = user_consent_id;
    let p_body_user_consent_request = user_consent_request;

    let uri_str = format!("{}/api/user/consent/{userConsentId}", configuration.base_path, userConsentId=crate::apis::urlencode(p_path_user_consent_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_user_consent_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserConsentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserConsentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUserConsentWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates a family with a given Id. OR Adds a user to an existing family. The family Id must be specified.
pub async fn update_user_family_with_id(configuration: &configuration::Configuration, family_id: &str, x_fusion_auth_tenant_id: Option<&str>, family_request: Option<models::FamilyRequest>) -> Result<models::FamilyResponse, Error<UpdateUserFamilyWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_family_id = family_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_family_request = family_request;

    let uri_str = format!("{}/api/user/family/{familyId}", configuration.base_path, familyId=crate::apis::urlencode(p_path_family_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_family_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FamilyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FamilyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUserFamilyWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Re-sends the verification email to the user. If the Application has configured a specific email template this will be used instead of the tenant configuration. OR Re-sends the verification email to the user. OR Generate a new Email Verification Id to be used with the Verify Email API. This API will not attempt to send an email to the User. This API may be used to collect the verificationId for use with a third party system.
pub async fn update_user_verify_email(configuration: &configuration::Configuration, application_id: Option<&str>, email: Option<&str>, send_verify_email: Option<&str>) -> Result<models::VerifyEmailResponse, Error<UpdateUserVerifyEmailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_application_id = application_id;
    let p_query_email = email;
    let p_query_send_verify_email = send_verify_email;

    let uri_str = format!("{}/api/user/verify-email", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_application_id {
        req_builder = req_builder.query(&[("applicationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_email {
        req_builder = req_builder.query(&[("email", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_send_verify_email {
        req_builder = req_builder.query(&[("sendVerifyEmail", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VerifyEmailResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VerifyEmailResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUserVerifyEmailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Re-sends the application registration verification email to the user. OR Generate a new Application Registration Verification Id to be used with the Verify Registration API. This API will not attempt to send an email to the User. This API may be used to collect the verificationId for use with a third party system.
pub async fn update_user_verify_registration(configuration: &configuration::Configuration, email: Option<&str>, application_id: Option<&str>, send_verify_password_email: Option<&str>) -> Result<models::VerifyRegistrationResponse, Error<UpdateUserVerifyRegistrationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_email = email;
    let p_query_application_id = application_id;
    let p_query_send_verify_password_email = send_verify_password_email;

    let uri_str = format!("{}/api/user/verify-registration", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_email {
        req_builder = req_builder.query(&[("email", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_application_id {
        req_builder = req_builder.query(&[("applicationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_send_verify_password_email {
        req_builder = req_builder.query(&[("sendVerifyPasswordEmail", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VerifyRegistrationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VerifyRegistrationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUserVerifyRegistrationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the user with the given Id. OR Reactivates the user with the given Id.
pub async fn update_user_with_id(configuration: &configuration::Configuration, user_id: &str, x_fusion_auth_tenant_id: Option<&str>, reactivate: Option<&str>, user_request: Option<models::UserRequest>) -> Result<models::UserResponse, Error<UpdateUserWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_query_reactivate = reactivate;
    let p_body_user_request = user_request;

    let uri_str = format!("{}/api/user/{userId}", configuration.base_path, userId=crate::apis::urlencode(p_path_user_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_reactivate {
        req_builder = req_builder.query(&[("reactivate", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUserWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the webhook with the given Id.
pub async fn update_webhook_with_id(configuration: &configuration::Configuration, webhook_id: &str, webhook_request: Option<models::WebhookRequest>) -> Result<models::WebhookResponse, Error<UpdateWebhookWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_webhook_id = webhook_id;
    let p_body_webhook_request = webhook_request;

    let uri_str = format!("{}/api/webhook/{webhookId}", configuration.base_path, webhookId=crate::apis::urlencode(p_path_webhook_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_webhook_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebhookResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebhookResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateWebhookWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates or updates an Entity Grant. This is when a User/Entity is granted permissions to an Entity.
pub async fn upsert_entity_grant_with_id(configuration: &configuration::Configuration, entity_id: &str, x_fusion_auth_tenant_id: Option<&str>, entity_grant_request: Option<models::EntityGrantRequest>) -> Result<(), Error<UpsertEntityGrantWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_entity_id = entity_id;
    let p_header_x_fusion_auth_tenant_id = x_fusion_auth_tenant_id;
    let p_body_entity_grant_request = entity_grant_request;

    let uri_str = format!("{}/api/entity/{entityId}/grant", configuration.base_path, entityId=crate::apis::urlencode(p_path_entity_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_x_fusion_auth_tenant_id {
        req_builder = req_builder.header("X-FusionAuth-TenantId", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_entity_grant_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpsertEntityGrantWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Validates the end-user provided user_code from the user-interaction of the Device Authorization Grant. If you build your own activation form you should validate the user provided code prior to beginning the Authorization grant.
pub async fn validate_device_with_id(configuration: &configuration::Configuration, user_code: Option<&str>, client_id: Option<&str>) -> Result<(), Error<ValidateDeviceWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_user_code = user_code;
    let p_query_client_id = client_id;

    let uri_str = format!("{}/oauth2/device/validate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_user_code {
        req_builder = req_builder.query(&[("user_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_client_id {
        req_builder = req_builder.query(&[("client_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ValidateDeviceWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Validates the provided JWT (encoded JWT string) to ensure the token is valid. A valid access token is properly signed and not expired. <p> This API may be used to verify the JWT as well as decode the encoded JWT into human readable identity claims.
pub async fn validate_jwt_with_id(configuration: &configuration::Configuration, ) -> Result<models::ValidateResponse, Error<ValidateJwtWithIdError>> {

    let uri_str = format!("{}/api/jwt/validate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ValidateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ValidateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ValidateJwtWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// It's a JWT vending machine!  Issue a new access token (JWT) with the provided claims in the request. This JWT is not scoped to a tenant or user, it is a free form  token that will contain what claims you provide. <p> The iat, exp and jti claims will be added by FusionAuth, all other claims must be provided by the caller.  If a TTL is not provided in the request, the TTL will be retrieved from the default Tenant or the Tenant specified on the request either  by way of the X-FusionAuth-TenantId request header, or a tenant scoped API key.
pub async fn vend_jwt_with_id(configuration: &configuration::Configuration, jwt_vend_request: Option<models::JwtVendRequest>) -> Result<models::JwtVendResponse, Error<VendJwtWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_jwt_vend_request = jwt_vend_request;

    let uri_str = format!("{}/api/jwt/vend", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_jwt_vend_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::JwtVendResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::JwtVendResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<VendJwtWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Administratively verify a user identity.
pub async fn verify_identity_with_id(configuration: &configuration::Configuration, verify_request: Option<models::VerifyRequest>) -> Result<(), Error<VerifyIdentityWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_verify_request = verify_request;

    let uri_str = format!("{}/api/identity/verify", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_verify_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VerifyIdentityWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Confirms a user's registration.   The request body will contain the verificationId. You may also be required to send a one-time use code based upon your configuration. When  the application is configured to gate a user until their registration is verified, this procedures requires two values instead of one.  The verificationId is a high entropy value and the one-time use code is a low entropy value that is easily entered in a user interactive form. The  two values together are able to confirm a user's registration and mark the user's registration as verified.
pub async fn verify_user_registration_with_id(configuration: &configuration::Configuration, verify_registration_request: Option<models::VerifyRegistrationRequest>) -> Result<(), Error<VerifyUserRegistrationWithIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_verify_registration_request = verify_registration_request;

    let uri_str = format!("{}/api/user/verify-registration", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_verify_registration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VerifyUserRegistrationWithIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

